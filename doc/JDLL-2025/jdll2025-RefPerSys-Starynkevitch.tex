\documentclass[final,a4]{beamer}
\usetheme{Madrid}
\title{le projet RefPerSys}
\author{Basile STARYNKEVITCH}
\date{mai 2025}
\usepackage{relsize}
\usepackage{luacode}
\usepackage{xcolor}
\usepackage{alltt}
%\usepackage{wasysym}
\usepackage{hyperref}
%\usepackage{newunicodechar}

%- \hypersetup{
%-   colorlinks   = true, %Colours links instead of ugly boxes
%-   urlcolor     = NavyBlue, %Colour for external hyperlinks
%-   linkcolor    = DarkGreen, %Colour of internal links
%-   citecolor   = DarkMagenta, %Colour of citations
%-   frenchlinks = true,
%- }

\begin{document}
 \begin{luacode*}
   local gitpip=io.popen("git log --no-color --format=oneline -1 --abbrev=16 --abbrev-commit -q | cut -d' ' -f1")
   gitid=gitpip:read()
   gitpip:close()
 \end{luacode*}
 \newcommand{\mygitid}{\luadirect{tex.print(gitid)}}

 \begin{frame}
   \titlepage

   \small{(un moteur d'inférences, ``intelligence artificielle'' symbolique)}

   \bigskip

   \begin{center}
   \begin{relsize}{-2}
     8 rue de la Faïencerie\\
     92340 Bourg-la-Reine
   \end{relsize}

   \bigskip

   \textbf{les opinions me sont personnelles}
   
   \bigskip
   
     \texttt{basile{@}starynkevitch.net}

     \bigskip

     \begin{fbox}
       {Journées Du Logiciel Libre - Lyon - mai 2025}
     \end{fbox}
     

     git {\texttt \mygitid}
   \end{center}
   
 \end{frame}

 \begin{frame}{Plan}

   \begin{relsize}{-1.5}
   \tableofcontents
   \end{relsize}
   
   \bigskip

   \begin{center}
     \relsize{+2}{\href{http://refpersys.org/}{\texttt{refpersys.org}}}

     \bigskip
     \includegraphics[width=0.45\textwidth]{refpersys-logo}

     \smallskip

     \relsize{-2}{Logo par Gaëtan Tapon}
   \end{center}
 \end{frame}

 \section{Introduction}
 \label{sec:intro}
 
 \begin{frame}{motivations pour RefPerSys}

   \begin{itemize}
   \item souveraineté numérique \small{(moins dépendre de logiciels
     états-uniens)}
   \item s'occuper 
   \item expérimenter un logiciel
   \item populariser et affiner des idées méconnues (celles de
     \href{https://fr.wikipedia.org/wiki/Jacques_Pitrat}{\it Jacques
       Pitrat})
   \item \textbf{un projet \textcolor{red}{en cours de dévelopement} qui cherche des contributeurs}
   \end{itemize}

   \bigskip
   \textbf{Le code source est libre} sous licence GPLv3+/CeCILLv2
   \textbf{sans garantie} sur
   \href{https://github.com/RefPerSys/RefPerSys}{\texttt{github.com/RefPerSys/RefPerSys}}
   et peut-être même difficilement utilisable en mai 2025.

   \bigskip

   \begin{center}
     \large\textsc{\textcolor{red}{REF}lexive \textcolor{red}{PER}sistent \textcolor{red}{SYS}tem}
   \end{center}
 \end{frame}
 
 \begin{frame}{historique et systèmes inspirants pour RefPerSys}

   \begin{itemize}

   \item \textbf{les moteurs d'inférences des systèmes experts} des années 1990
     \href{https://clipsrules.net/}{\textsc{CLIPSrules}} (NASA)

   \item \textbf{le système \textcolor{red}{CAIA}} (``chercheur
     artificiel en intelligence artificielle'') de J.Pitrat en
     {\texttt{\href{https://github.com/bstarynk/caia-pitrat}{github.com/bstarynk/caia-pitrat/}}}
     qui auto-génère son demi-million de lignes de C (1990-2018)
     
   \item \textbf{les outils d'aide à la démonstration} ou assistants
     de preuve \href{https://rocq-prover.org/}{\textsc{Rocq}} (ex
     \textsc{Coq})

     \item La problèmatique de \textbf{\textcolor{red}{l'amorçage des
         compilateurs}}: tous les compilateurs se compilent
       eux-mêmes. Idéalement \textit{\textcolor{red}{RefPerSys devrait générer son
         propre code}}.
   \end{itemize}

   \bigskip

   En France, il existe une grosse culture mathématique de systèmes
   formels de preuve. Ma philosophie est plus pragmatique et plus ludique.
   
 \end{frame}
 
 \begin{frame}{une propriété méconnue de Linux: les greffons à foison}


   Un programme sous Linux est {\relsize{-1}{(très souvent)}}
   utilisateur de nombreuses bibliothèques dynamiques
   {\relsize{-1}{(``shared objects'')}}, les fichiers
   \texttt{lib*.so}. Ce mécanisme optimise l'utilisation de la mémoire
   RAM et il est utilisé pour les greffons
   {\relsize{-1}{(``plugins'')}} chargés par la fonction
   \textbf{\texttt{\href{https://man7.org/linux/man-pages/man3/dlopen.3.html}{dlopen(3)}}}. Le
   programme obtient par
   \textbf{\texttt{\href{https://man7.org/linux/man-pages/man3/dlsym.3.html}{dlsym(3)}}},
   durant l'exécution, les fonctions d'un greffon à partir de leur nom.

   \medskip
     
   Un grand nombre de programmes sous Linux {\relsize{-1.5}{(dont le
       navigateur \href{https://firefox.org}{\textsc{Firefox}},
       l'éditeur programmable
       \href{https://www.gnu.org/software/emacs/}{\textsc{GNU emacs}},
       le compilateur \href{https://gcc.gnu.org/}{\textsc{Gcc}}, les
       interprètes de commandes
       \href{https://www.gnu.org/software/bash/}{\textsc{Bash}} ou
       \href{https://zsh.org}{\textsc{Zsh}} ou
       \href{https://lua.org}{\textsc{Lua})}}} acceptent des greffons,
   pour permettre d'en étendre le comportement. Ceux-ci peuvent être
   codés par d'autres dévelopeurs.

   \bigskip

   En pratique \textbf{un programme qui s'exécute} (son processus)
   \textbf{peut charger \textcolor{red}{un grand nombre} de greffons}
   (dizaines ou centaines de milliers).

   Donc \textbf{un programme \textcolor{red}{peut générer beaucoup de greffons}
     temporaires}.

   \smallskip

   \small{Cf
   \href{https://github.com/bstarynk/misc-basile/blob/master/manydl.c}{\texttt{manydl.c}
     dans \texttt{github.com/bstarynk/misc-basile}}.}

 \end{frame}

 \begin{frame}{Chargement et déchargement de code, une idée ancienne}

   Dans les années 1950 ou 1960, \textbf{les ordinateurs avaient peu
     de mémoire} {\relsize{-1.5}{(quelques kilo-octets ou un-demi
       méga-octet)}} \textbf{et} {\relsize{-0.5}{l'IBM 1130, les
       CAB500 et CAB2020 de la
       \href{https://fr.wikipedia.org/wiki/Soci\%C3\%A9t\%C3\%A9_d\%27\%C3\%A9lectronique_et_d\%27automatisme}{SEA},
       l'IBM 360 et d'autres machines}}\footnote{Les µ-ordinateurs des
   années 1970 ou 1980 aussi: PC/XT, TRS-80, Amiga 500.}
   \textbf{chargeaient le code par bouts}. \textbf{Un segment de code
     devenu inutile était supprimé de la mémoire centrale}, et la
   gestion fine du chargement et déchargement de ces segments
   nécessitait la coopération des programmeurs humains, du système
   d'exploitation (le ``moniteur'') et était une source de bogues
   intéressants.

   \bigskip

   Sous Linux, il n'est guère indispensable de décharger un
   greffon\footnote{L'exception serait un code hypothétique de calcul
   qui tourne pendant des mois sur un \textit{super-calculateur} du
   \href{https://top500.org/}{\texttt{top500.org}} en chargeant des
   millions de greffons générés temporairement.\\} par
   \textbf{\texttt{\href{https://man7.org/linux/man-pages/man3/dlclose.3.html}{dlclose(3)}}}. La
   puissance des machines et la performance du noyau
   {\relsize{-1.5}{(sous-système de gestion de la mémoire virtuelle)}}
   permet de ne pas le faire\footnote{On accepte alors une fuite
   mémoire sans dommage.\\}.

 \end{frame}

 \begin{frame}{Génération de code, une idée ancienne}

  Les compilateurs traduisent un code source (compréhensible par le
  dévelopeur) en du code machine\footnote{La notion de code objet ou
  intermédiaire est apparue progressivement dans les années 1960;
  certaines architectures -dont Harvard, qu'on retrouve encore dans
  les micro-contrôleurs à l'intérieur de nos claviers et de nos
  chaudières- séparent la mémoire du code et celles des données.} et
  existaient déjà dans les années 1950 ou 1960 (Cobol, Fortran, PAF,
  IPL-V, Lisp).

  \bigskip

  De nos jours, \textbf{les dévelopeurs utilisent des logiciels}
  spécialisés \textbf{générateurs de code} (en C par exemple, ou en
  Java ou Ocaml): \href{https://www.gnu.org/software/bison/}{GNU
    bison} comme \href{https://carburetta.com/}{Carburetta} ou
  \href{https://gallium.inria.fr/~fpottier/menhir/}{Menhir} génèrent
  tous du code pour faciliter l'analyse lexicale ou syntaxique. La
  théorie des languages formels est mûre (Chomsky).
 \end{frame}

 \begin{frame}{Génération de code, une idée moderne}

  Des bibliothèques logicielles pour générer du code existent:
  \href{https://www.gnu.org/software/lightning/}{GNU lightning},
  \href{https://asmjit.com/}{AsmJit}, et le compilateur GCC fournit sa
  \href{https://gcc.gnu.org/onlinedocs/jit/}{libgccjit}

  \bigskip
  
  Le Common Lisp libre \href{https://sbcl.org/}{SBCL} génère du code
  machine à chaque interaction de son utilisateur.

  \bigskip
  *
  La plupart des implémentations de Java ont une JVM qui traduit le code-octets (java bytecode) en du code machine.

 \end{frame}

 \begin{frame}{Évaluation partielle: une manière d'optimiser}

Beaucoup de calculs longs\footnote{La météo nationale calcule le temps
de demain en des heures de calcul sur super-calcuteur; de même en
astrophysique -simulation de collisions de galaxies-; ou en
bioinformatique -simulation des mouvements moléculaires dans une
cellule-.\\} (durant des heures ou des semaines) dépendent de plusieurs
paramètres.
\medskip

Certains paramètres sont constants durant tout le calcul\footnote{Pour
la météo, les mesures physiques entrées des paramètres des capteurs,
mais les résultats internes intermediaires varient durant ce calcul
itératif.\\}.
\medskip

Dans certains cas, il peut être utile de particulariser le code pour ces paramètres constants.

Par exemple simpliste, une affectation pourrait être \texttt{u := a*x
  + b*y + c} et si on sait que \texttt{a} et \texttt{c} sont nuls elle
se simplifie en \texttt{u := b*y} plus rapide à calculer.


 \end{frame}

 \begin{frame}{Évaluation partielle: formalisation}
   
Formellement:

\begin{itemize}
\item on connait le code source $\sigma$ (millions de lignes)
\item ce code calcule sur des paramètres fixes \textcolor{brown}{$\pi_1, \pi_2, \ldots \pi_n$}
\item ce code calcule sur des entrées variables $v_1, v_2, \ldots v_p$
  
\item les résultats obtenus sont $r_1, r_2 \ldots r_q = \sigma (\textcolor{brown}{\pi_1, \pi_2, \ldots \pi_n}, v_1, v_2 \ldots v_p)$
%\item par des algorithmes complexes on produit et génère un code
%  dérivé $\delta$ qui dépend des paramètres $\pi_i$ tel que
%  $\delta(v_1, v_2, \ldots v_p) = \sigma(\textcolor{brown}{$\pi_1, \pi_2, \ldots \pi_n},
%  v_1, v_2 \ldots v_p)$
\end{itemize}

La dérivation du code $\delta$ à partir du code source $\sigma$ et des
valeurs connues des paramètres fixes \textcolor{brown}{$\pi_i$} est compliquée (peut être indécidable). 
 \end{frame}

 
\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Local Variables: ;;
%% compile-command: "./build-refpersys-jdll2025.sh" ;;
%% End: ;;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
