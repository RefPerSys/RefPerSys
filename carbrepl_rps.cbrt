/****************************************************************
 * file carbrepl_rps.cbrt
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 * Description:
 *      This file is part of the Reflective Persistent System.
 *      It is its Carburetta grammar and parser
 *      see https://carburetta.com/
 *
 * Author(s):
 *      Basile Starynkevitch, France   <basile@starynkevitch.net>
 *
 *      © Copyright 2025 The Reflective Persistent System Team
 *      team@refpersys.org & http://refpersys.org/
 *
 * License: GPLv3+ (file COPYING-GPLv3)
 *    This software is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version. NO WARRANTY
 ****************************************************************/

#include "refpersys.hh"
#pragma message "prologue part of carbrepl_rps.cbrt"

#ifndef RPS_GITID
#error RPS_GITID is not defined by compilation command
#endif

constexpr unsigned rps_magic_carbrepl_data = 696140743; // 0x297e43c7
struct rps_carbrepl_data_st {
  unsigned cardata_magic;       // always  rps_magic_carbrepl_data
  intptr_t cardata_i;
  double cardata_d;
  std::string cardata_str;
  void* cardata_ptr;
  Rps_ObjectRef cardata_ob1;
  Rps_ObjectRef cardata_ob2;
  Rps_ObjectRef cardata_obdelim;
  Rps_ObjectRef cardata_obop;
  Rps_Value cardata_v1;
  Rps_Value cardata_v2;
  Rps_Value cardata_vleft;
  Rps_Value cardata_vright;
  Rps_InstanceValue cardata_vinst;
  inline void reset_carbdata(int li=__builtin_LINE());
};

void
rps_carbrepl_data_st::reset_carbdata(int lin)
{
  RPS_ASSERT(cardata_magic == rps_magic_carbrepl_data);
  cardata_i = 0;
  cardata_d = 0.0;
  cardata_str.erase();
  memset((void*)&cardata_ptr, 0,
         sizeof(*this)-offsetof(rps_carbrepl_data_st, cardata_ptr));
  RPS_ASSERT(cardata_magic == rps_magic_carbrepl_data);
  RPS_DEBUG_LOG(REPL, "resetting carbrepl_data@" << (void*)this << " line#" << lin);
} // end rps_carbrepl_data_st::reset_carbdata

extern "C" void rps_carbrepl_do_display_command(Rps_CallFrame*callframe, Rps_ObjectRef obenv, Rps_Value expr);
static void rps_carbrepl_constructor_replnt_object(Rps_ObjectRef&obr, int lin);
static void rps_carbrepl_destructor_replnt_object(Rps_ObjectRef&obr, int lin);
static const char* rps_carbrepl_symname_at(int symnum, int lin);
#define  RPS_CARBREPL_SYMBOL_NAME(Num) rps_carbrepl_symname_at(Num, __LINE__)


static void rps_carbrepl_constructor_replnt_atom(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_atom(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_set(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_set(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_expr(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_expr(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_factor(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_factor(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_term(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_term(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_value(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_value(Rps_Value&val, int lin);
struct rps_carbrepl_data_st;


/// this is used by %on_next_token
/***
When the parser (not the scanner) needs a new input terminal symbol, the specified action code snippet is executed.

If the directive is not specified, the default behavior is to return <prefix>FEED_ME.

A valid use-case for %on_next_token is to feed the parser with a new symbol by storing its ordinal value in sym without returning to the caller
****/

extern "C" int rps_carbrepl_next_token(Rps_CallFrame*callframe, Rps_TokenSource*tksrc, int& sym, struct rps_carbrepl_data_st&carbdata, int lin);
int rps_carbrepl_next_token(Rps_CallFrame*callframe, Rps_TokenSource*tksrc, int& sym, struct rps_carbrepl_data_st&carbdata, int lin);

extern "C" struct rpscarbrepl_stack;

/// The following is related to the the visitor facility in carburetta 0.8.25 or newer (april 2025)
/// See https://github.com/kingletbv/carburetta/issues/4
extern "C" void rps_carbrepl_garbage_collect_visit_stack(struct rpscarbrepl_stack*,Rps_GarbageCollector*);
%visit_params Rps_GarbageCollector*visitgc, rps_carbrepl_data_st*carbdata


%header%
#pragma message "header part of carbrepl_rps.cbrt"
extern "C" const char rps_carbrepl_gitid[];
extern "C" const char rps_carbrepl_date[];
extern "C" const char rps_carbrepl_shortgitid[];
%%

%prefix rpscarbrepl_
//forbidden %token_action here since it must follow %token_type, %type, %class, %common_type or %common_class directive
%end_token EOF

%token ATSIGN
 //ATSIGN being untyped cannot have a token_action

%token INT
%type INT: intptr_t
%token_action {  _Pragma("message \"token_action for INT\"");		\
  $$ = carbdata.cardata_i;						\
  RPS_DEBUG_LOG(REPL, "token_action for INT tksrc=" << *tksrc		\
		<< " cardata_i=" << carbdata.cardata_i);		\
  RPS_FATALOUT("INT token_action is incomplete tksrc="                  \
	       << tksrc << " sym=" << sym				\
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)			\
               << RPS_FULL_BACKTRACE_HERE(1, "token_action INT"));      \
 }


%token DOUBLE
%type DOUBLE: double
%token_action {  _Pragma("message \"token_action for DOUBLE\"");	\
  RPS_DEBUG_LOG(REPL, "token_action for DOUBLE tksrc=" << *tksrc	\
		<< " cardata_d=" << carbdata.cardata_d);		\
  /* should assign $$ for DOUBLE */					\
  $$ = carbdata.cardata_d;						\
  RPS_FATALOUT("DOUBLE token_action is incomplete tksrc="		\
	       << tksrc << " sym=" << sym 				\
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)			\
	       << " cardata_d="	  << carbdata.cardata_d			\
               << RPS_FULL_BACKTRACE_HERE(1, "token_action DOUBLE"));   \
 }

%token STRING
%type STRING: std::string
%token_action { _Pragma("message \"token_action for STRING\"");		\
  /*  assign $$ for STRING */					\
  RPS_DEBUG_LOG(REPL, "token_action for STRING tksrc=" << *tksrc	\
		<< " cardata_str="					\
		<< Rps_QuotedC_String(carbdata.cardata_str));		\
  $$ = carbdata.cardata_str; 						\
  RPS_FATALOUT("STRING token_action is incomplete tksrc=" << tksrc	\
	       << " sym=" << sym					\
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)			\
               << RPS_FULL_BACKTRACE_HERE(1, "token_action STRING"));   \
 }

%token NAME
%type NAME: std::string
%token_action {  _Pragma("message \"token_action for NAME\"");		\
  RPS_DEBUG_LOG(REPL, "token_action for NAME tksrc=" << *tksrc		\
		<< " cardata_str=" << carbdata.cardata_str);		\
  /* should assign $$ for NAME using cardata_str */			\
  RPS_FATALOUT("NAME token_action is incomplete tksrc=" << tksrc	\
	       << " sym=" << sym					\
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)			\
		<< " cardata_str=" << carbdata.cardata_str		\
               << std::endl						\
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action NAME"));	\
 }

%token OID
%type OID: Rps_Id
%token_action { _Pragma("message \"token_action for OID\"");		\
  /* should assign $$ for OID */					\
  RPS_DEBUG_LOG(REPL, "token_action for OID tksrc=" << *tksrc		\
		<< " cardata_str=" << carbdata.cardata_str);		\
  RPS_FATALOUT("OID token_action is incomplete tksrc=" << tksrc		\
	       << " sym=" << sym					\
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)			\
               << RPS_FULL_BACKTRACE_HERE(1, "token_action NAME"));     \
 }

%token KEYW_DISPLAY
%token_action { _Pragma("message \"token_action for KEYW_DISPLAY\"");  \
  RPS_DEBUG_LOG(REPL, "token_action for KEYW_DISPLAY tksrc=" << *tksrc); \
  /* should assign $$ for KEYW_DISPLAY */ \
  RPS_FATALOUT("KEYW_DISPLAY token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action KEYW_DISPLAY"));     \
 }

%token KEYW_OBJECT
%token_action { _Pragma("message \"token_action for KEYW_OBJECT\""); \
  RPS_DEBUG_LOG(REPL, "token_action for KEYW_OBJECT tksrc=" << *tksrc); \
  /* should assign $$ for KEYW_OBJECT */ \
  RPS_FATALOUT("KEYW_OBJECT token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action KEYW_OBJECT"));      \
 }

%token KEYW_PUT
%token_action { _Pragma("message \"token_action for KEYW_PUT\"");  \
  RPS_DEBUG_LOG(REPL, "token_action for KEYW_PUT tksrc=" << *tksrc); \
  /* should assign $$ for KEYW_PUT */ \
  RPS_FATALOUT("KEYW_OBJECT token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action KEYW_OBJECT"));      \
 }
 

%token DOT
%token_action { _Pragma("message \"token_action for DOT\""); \
  /* should assign $$ for DOT */ \
  RPS_DEBUG_LOG(REPL, "token_action for DOT tksrc=" << *tksrc); \
  RPS_FATALOUT("DOT token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action DOT"));      \
 }

%token COMMA
%token_action { _Pragma("message \"token_action for COMMA\""); \
  /* should assign $$ for COMMA */ \
  RPS_DEBUG_LOG(REPL, "token_action for COMMA tksrc=" << *tksrc); \
  RPS_FATALOUT("COMMA token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action COMMA"));      \
 }

%token ASSIGN
%token_action {_Pragma("message \"token_action for ASSIGN\""); \
  /* should assign $$ for ASSIGN */ \
  RPS_DEBUG_LOG(REPL, "token_action for ASSIGN tksrc=" << *tksrc); \
  RPS_FATALOUT("ASSIGN token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action ASSIGN"));   \
 }

%token LEFTPAREN
%token_action {_Pragma("message \"token_action for LEFTPAREN\""); \
  /* should assign $$ for LEFTPAREN */ \
  RPS_DEBUG_LOG(REPL, "token_action for LEFTPAREN tksrc=" << *tksrc); \
  RPS_FATALOUT("LEFTPAREN token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action LEFTPAREN"));        \
 }

%token RIGHTPAREN
%token_action {_Pragma("message \"token_action for RIGHTPAREN\""); \
  RPS_DEBUG_LOG(REPL, "token_action for RIGHTPAREN tksrc=" << *tksrc); \
  /* should assign $$ for RIGHTPAREN */ \
  RPS_FATALOUT("RIGHTPAREN token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action RIGHTPAREN"));       \
 }
//


%token LEFTBRACE
%token_action {_Pragma("message \"token_action for LEFTBRACE\""); \
  /* should assign $$ for LEFTBRACE */ \
  RPS_DEBUG_LOG(REPL, "token_action for LEFTBRACE tksrc=" << *tksrc); \
  RPS_FATALOUT("LEFTBRACE token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action LEFBRACE"));        \
 }

%token RIGHTBRACE
%token_action {_Pragma("message \"token_action for RIGHTBRACE\""); \
  RPS_DEBUG_LOG(REPL, "token_action for RIGHTBRACE tksrc=" << *tksrc); \
  /* should assign $$ for RIGHTBRACE */ \
  RPS_FATALOUT("RIGHTBRACE token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action RIGHTBRACE"));       \
 }
//

%token PLUS 
%token_action {_Pragma("message \"token_action for PLUS\""); \
  /* should assign $$ PLUS */ \
  RPS_DEBUG_LOG(REPL, "token_action for PLUS tksrc=" << *tksrc); \
  RPS_FATALOUT("PLUS token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action PLUS"));     \
 }
//

%token MINUS 
%token_action {_Pragma("message \"token_action for MINUS\""); \
  RPS_DEBUG_LOG(REPL, "token_action for MINUS tksrc=" << tksrc); \
  /* should assign $$ MINUS */ \
  RPS_FATALOUT("MINUS token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action MINUS"));    \
 }
//


%token ASTERISK 
%token_action {_Pragma("message \"token_action for ASTERISK\""); \
  RPS_DEBUG_LOG(REPL, "token_action for ASKTE tksrc=" << *tksrc); \
  /* should assign $$ ASTERISK */ \
  RPS_FATALOUT("ASTERISK token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action ASTERISK")); \
 }
//

%token SLASH 
%token_action {_Pragma("message \"token_action for SLASH\""); \
  RPS_DEBUG_LOG(REPL, "token_action for SLASH tksrc=" << *tksrc); \
  /* should assign $$ SLASH */ \
  RPS_FATALOUT("SLASH token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE_HERE(1, "token_action SLASH"));    \
 }
//

%grammar%
%params Rps_TokenSource* tksrc, Rps_CallFrame* callframe, rps_carbrepl_data_st&carbdata
%nt replnt_input replnt_command
%nt replnt_atom replnt_object replnt_expr replnt_term replnt_factor
%nt replnt_value replnt_set replnt_objectseq replnt_restobjectseq


%type replnt_objectseq: Rps_ObjectVector

%type replnt_restobjectseq: Rps_ObjectVector


// When the parser (not the scanner) needs a new input terminal symbol, the specified action code snippet is executed.
// we probably need to use Rps_TokenSource::lookahead_token
%on_next_token {_Pragma("message \"on_next_token code\"");              \
    RPS_POSSIBLE_BREAKPOINT();                                          \
    RPS_DEBUG_LOG(REPL, "°+on_next_token start tksrc=" << *tksrc        \
                  << " sym:" << sym                                     \
                  << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)               \
                  << std::endl                                          \
                  << RPS_FULL_BACKTRACE_HERE(1, "¤+on_next_token"));    \
    RPS_POSSIBLE_BREAKPOINT();                                          \
    _Pragma("message \"FIXME the value of next token\"");               \
    int ntk = rps_carbrepl_next_token(callframe, tksrc, sym,            \
                                      carbdata,                         \
                                      __LINE__);                        \
    RPS_DEBUG_LOG(REPL, "°-on_next_token tksrc=" << *tksrc << " is "    \
                  << ntk << "::" << RPS_CARBREPL_SYMBOL_NAME(ntk)       \
		  << std::endl						\
                  << RPS_FULL_BACKTRACE_HERE(1, "¤-on_next_token"));    \
    return ntk; }



%type replnt_object: Rps_ObjectRef
%constructor rps_carbrepl_constructor_replnt_object($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_object($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_object\"");RPS_ASSERT(visitgc);$$->gc_mark(*visitgc);}

%type replnt_atom: Rps_Value
%constructor rps_carbrepl_constructor_replnt_atom($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_atom($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_atom\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}


%type replnt_expr: Rps_Value
%constructor rps_carbrepl_constructor_replnt_expr($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_expr($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_expr\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}



%type replnt_term: Rps_Value
%constructor rps_carbrepl_constructor_replnt_term($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_term($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_term\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}



%type replnt_factor: Rps_Value
%constructor rps_carbrepl_constructor_replnt_factor($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_factor($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_factor\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}


%type replnt_value: Rps_Value
%constructor rps_carbrepl_constructor_replnt_value($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_value($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_value\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}


%type replnt_input: int
%type replnt_command: int


/* the start symbol is the first non-terminal */
replnt_input: EOF {
  _Pragma("message \"replnt_input as EOF in carbrepl_rps.cbrt\"");
  RPS_ASSERT("empty replnt_input" && tksrc != nullptr);
  RPS_DEBUG_LOG(REPL, "replnt_input as EOF tksrc=" << *tksrc); \
  RPS_ASSERT(callframe != nullptr && callframe->is_good_call_frame());
  $$ = 0;
}

replnt_input: replnt_command replnt_input {
   _Pragma("message \"replnt_input as replnt_command replnt_input in carbrepl_rps.cbrt\"");
   RPS_ASSERT("command replnt_input" && tksrc != nullptr);
   RPS_ASSERT(callframe != nullptr && callframe->is_good_call_frame());
   $$ = $1 + 1;
}

replnt_command: ATSIGN KEYW_DISPLAY replnt_expr {
   _Pragma("message \"replnt_command as KEYW_DISPLAY replnt_expr in carbrepl_rps.cbrt\"");
   RPS_DEBUG_LOG(REPL, "show carburetta command:" << $2);
   RPS_ASSERT(callframe != nullptr && callframe->is_good_call_frame());
   RPS_POSSIBLE_BREAKPOINT();
   rps_carbrepl_do_display_command(callframe, rps_get_first_repl_environment(), $2);
   RPS_POSSIBLE_BREAKPOINT();
   $$ = 1;
}

replnt_command: ATSIGN KEYW_PUT replnt_object DOT replnt_object ASSIGN replnt_expr {
   _Pragma("message \"replnt_command as KEYW_PUT replnt_object DOT replnt_object ASSIGN replnt_expr in carbrepl_rps.cbrt\"");
   RPS_DEBUG_LOG(REPL, "put carburetta command:" << $2 << " attr " << $4 << " expr " << $6);
   RPS_POSSIBLE_BREAKPOINT();
   RPS_ASSERT(callframe != nullptr && callframe->is_good_call_frame());
}

replnt_command: error {
  RPS_POSSIBLE_BREAKPOINT();
  RPS_WARNOUT("invalid syntax for command");
}

replnt_atom: INT {
_Pragma("message \"replnt_atom as INT in carbrepl_rps.cbrt\"");
 RPS_POSSIBLE_BREAKPOINT();
  $$ = Rps_Value::make_tagged_int($0);
  RPS_DEBUG_LOG(REPL, "atom is INT " << $$);
}

replnt_atom: DOUBLE {
_Pragma("message \"replnt_atom as DOUBLE in carbrepl_rps.cbrt\"");
  $$ = Rps_DoubleValue($0);
  RPS_DEBUG_LOG(REPL, "atom is DOUBLE " << $$);
}

replnt_atom: STRING {
_Pragma("message \"replnt_atom as STRING in carbrepl_rps.cbrt\"");
  $$ = Rps_StringValue($0);
  RPS_DEBUG_LOG(REPL, "atom is STRING " << $$);
}

replnt_atom: replnt_object {
  _Pragma("message \"replnt_atom as replnt_object in carbrepl_rps.cbrt\"");
  $$ = Rps_ObjectValue($0);
  RPS_DEBUG_LOG(REPL, "atom is object " << $$);
}

replnt_atom: replnt_set {
_Pragma("message \"replnt_atom as replnt_set in carbrepl_rps.cbrt\"");
 RPS_POSSIBLE_BREAKPOINT();
 $$ = Rps_SetValue($0);
 RPS_DEBUG_LOG(REPL, "atom is set " << $$);
}

%type replnt_set: Rps_SetValue

replnt_set: LEFTBRACE replnt_objectseq RIGHTBRACE {
_Pragma("message \"replnt_set in carbrepl_rps.cbrt\"");
 RPS_POSSIBLE_BREAKPOINT();
 $$ = Rps_SetValue($1);
  RPS_DEBUG_LOG(REPL, "set " << $$);
}

replnt_objectseq: /*empty*/ {
_Pragma("message \"replnt_objectseq empty in carbrepl_rps.cbrt\"");
 RPS_POSSIBLE_BREAKPOINT();
 $$ = Rps_ObjectVector();
 RPS_DEBUG_LOG(REPL, "empty objectseq " << $$);
}

replnt_objectseq: replnt_object replnt_restobjectseq {
 $$ = Rps_ObjectVector();
 $$.reserve($1.size()+2);
 $$.push_back($0);
 for (Rps_ObjectRef compob: $1)
   $$.push_back(compob);
 RPS_DEBUG_LOG(REPL, "replnt_objectseq is " << $$);
}

replnt_restobjectseq: /*empty*/ {
_Pragma("message \"replnt_restobjectseq empty in carbrepl_rps.cbrt\"");
 RPS_POSSIBLE_BREAKPOINT();
 $$ = Rps_ObjectVector();
 RPS_DEBUG_LOG(REPL, "empty restobjectseq " << $$);
}

replnt_restobjectseq: COMMA replnt_objectseq {
_Pragma("message \"replnt_restobjectseq with comma in carbrepl_rps.cbrt\"");
 RPS_POSSIBLE_BREAKPOINT();
 $$ = $1;
 RPS_DEBUG_LOG(REPL, "comma restobjectseq " << $$);
}

replnt_object: NAME {
  _Pragma("message \"replnt_object as NAME in carbrepl_rps.cbrt\"");
  $$ = Rps_PayloadSymbol::find_named_object($0);
  RPS_DEBUG_LOG(REPL, "object is name " << $$);
}

replnt_object: OID {
  _Pragma("message \"replnt_object as OID in carbrepl_rps.cbrt\"");
  $$ = Rps_ObjectRef::really_find_object_by_oid($0);
  RPS_DEBUG_LOG(REPL, "object is oid " << $$);
}


replnt_expr: KEYW_OBJECT replnt_object {
  _Pragma("message \"replnt_expr as KEYW_OBJECT replnt_object in carbrepl_rps.cbrt\"");
  $$ = Rps_ObjectValue($1);
  RPS_DEBUG_LOG(REPL, "expr is object " << $$);
}


replnt_expr: replnt_term                      {
  _Pragma("message \"replnt_expr as replnt_term in carbrepl_rps.cbrt\"");
  RPS_DEBUG_LOG(REPL, "expr is term " << $$);
  $$ = $0;
}

replnt_expr: replnt_expr PLUS replnt_term            {            
  _Pragma("message \"replnt_expr as replnt_expr PLUS replnt_term in carbrepl_rps.cbrt\"");
  RPS_DEBUG_LOG(REPL, "expr is sum of " << $0 << " and " << $2);
  RPS_ASSERT(carbdata.cardata_magic == rps_magic_carbrepl_data);
  static Rps_Id id_plus_delim;
  if (!id_plus_delim)
    id_plus_delim = Rps_Id("_4ShDsOWk7al02eDRTM");
  static Rps_Id id_plus_binop;
  if (!id_plus_binop)
    id_plus_binop = Rps_Id("_51jvc2mFhql03qwRg6");
  carbdata.cardata_obdelim =
    Rps_ObjectRef::find_object_or_fail_by_oid(callframe,
                                              id_plus_delim); // "plus!delim"∈repl_delimiter
  carbdata.cardata_obop =
    Rps_ObjectRef::find_object_or_fail_by_oid(callframe,
                                              id_plus_binop); // "plus!binop"∈repl_binary_operator
  /// for the garbage collector we need to...
  carbdata.cardata_vleft = $0;
  carbdata.cardata_vright = $2;
  _Pragma("message \"take inspiration from parsrepl_rps.cc function Rps_TokenSource::parse_sum\"");
  $$ = carbdata.cardata_vinst
    = Rps_InstanceValue(RPS_ROOT_OB(_55Z5Wgzuprq01MU6Br), //repl_binary_operator∈class h:2852622165
                        {carbdata.cardata_obop, $0, $2});
  RPS_DEBUG_LOG(REPL, "replnt_expr: replnt_expr PLUS replnt_term result is " << $$
                << " left:" << $0 << " right:" << $2 << std::endl
                << RPS_FULL_BACKTRACE_HERE(1, "replnt_expr: replnt_expr PLUS replnt_term"));
  //FIXME:carbdata.cardata_vinst->put_pesistent_metadata(<some-object>,<some-integer>);
  carbdata.reset_carbdata();
}

replnt_expr: replnt_expr MINUS replnt_term           {
  _Pragma("message \"replnt_expr as replnt_expr MINUS replnt_term in carbrepl_rps.cbrt\"");
  // $$ = $0 - $2;
}
  
replnt_term: replnt_factor                    {
  _Pragma("message \"replnt_term as replnt_factor in carbrepl_rps.cbrt\"");
  $$ = $0;
}

replnt_term: replnt_term ASTERISK replnt_factor      {
  _Pragma("message \"replnt_term as replnt_term ASTERISK replnt_factor in carbrepl_rps.cbrt\"");
  //  $$ = $0 * $2;
  }

replnt_term: replnt_term SLASH replnt_factor         {
  _Pragma("message \"replnt_term as replnt_term SLASH replnt_factor in carbrepl_rps.cbrt\"");
  //  $$ = $0 / $2;
  }
  
replnt_factor: replnt_atom                   {
  _Pragma("message \"replnt_factor as replnt_atom in carbrepl_rps.cbrt\"");
  $$ = $0;
  RPS_DEBUG_LOG(REPL, "factor is atom " << $$);
  }

replnt_factor: MINUS replnt_factor            {
  _Pragma("message \"replnt_factor as MINUS replnt_factor in carbrepl_rps.cbrt\"");
  // $$ = -$1;
  }

replnt_factor: LEFTPAREN replnt_expr RIGHTPAREN {
  _Pragma("message \"replnt_factor as LEFTPAREN replnt_factor RIGHTPAREN in carbrepl_rps.cbrt\"");
  RPS_DEBUG_LOG(REPL, "factor is parenthesised expr " << $1);
  // $$ = $1;
  }



%%


/// temporary workaround github.com/kingletbv/carburetta/issues/10
#line 608 "carbrepl_rps.cbrt"



#pragma message "trailer of carbrepl_rps.cbrt"

//// for objects in REPL
void
rps_carbrepl_constructor_replnt_object(Rps_ObjectRef&obr, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  _Pragma("message \"rps_carbrepl_constructor_replnt_object\"");
  obr = nullptr;
} // end rps_carbrepl_constructor_replnt_object

void
rps_carbrepl_destructor_replnt_object(Rps_ObjectRef&obr, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  _Pragma("message \"rps_carbrepl_replnt_object_destructor\"");
  obr = nullptr;
} // end rps_carbrepl_replnt_object_destructor



//// for atoms in REPL
void
rps_carbrepl_constructor_replnt_atom(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_atom\"");
} // end rps_carbrepl_constructor_replnt_atom

void
rps_carbrepl_destructor_replnt_atom(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_atom\"");
} // end rps_carbrepl_replnt_object_destructor_replnt_atom


//// for sets in REPL
void
rps_carbrepl_constructor_replnt_set(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_set\"");
} // end rps_carbrepl_constructor_replnt_atom

void
rps_carbrepl_destructor_replnt_set(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_set\"");
} // end rps_carbrepl_replnt_object_destructor_replnt_set




//// for expressions in REPL
void
rps_carbrepl_constructor_replnt_expr(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_expr\"");
} // end rps_carbrepl_constructor_replnt_expr

void
rps_carbrepl_destructor_replnt_expr(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_expr\"");
} // end rps_carbrepl_replnt_destructor_replnt_expr

void
rps_carbrepl_constructor_replnt_term(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_term\"");
} // end rps_carbrepl_constructor_replnt_term

void
rps_carbrepl_destructor_replnt_term(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_term\"");
} // end rps_carbrepl_replnt_destructor_replnt_term

void
rps_carbrepl_constructor_replnt_factor(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_factor\"");
} // end rps_carbrepl_constructor_replnt_factor

void
rps_carbrepl_destructor_replnt_factor(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_factor\"");
} // end rps_carbrepl_replnt_destructor_replnt_factor

void
rps_carbrepl_constructor_replnt_value(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_value\"");
} // end rps_carbrepl_constructor_replnt_factor

void
rps_carbrepl_destructor_replnt_value(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_value\"");
} // end rps_carbrepl_replnt_destructor_replnt_value

int
rps_carbrepl_next_token(Rps_CallFrame*callframe, Rps_TokenSource*tksrc,
                        int& sym, struct rps_carbrepl_data_st&carbdata, int lin)
{
  static thread_local int callcnt;
  /// used by %on_next_token above:
  bool gdb_do_return=false; // to be set from GDB
  int gdb_returned= 0;      // to be set from GDB
  int callnum = ++callcnt;
  RPS_POSSIBLE_BREAKPOINT();
  RPS_LOCALFRAME(/*descr:*/RPS_ROOT_OB(_4CZZ2JlnkQT02YJ6sM), //replnt_command∈symbol
                 callframe,
                 Rps_ObjectRef obenv;
                 Rps_Value tokv;
                 Rps_ObjectRef kindtokob;
                 Rps_Value valtokv;
                 Rps_Value nextokv;
                );
  RPS_ASSERT(tksrc);
  RPS_ASSERT(callframe && callframe->is_good_call_frame());
  RPS_DEBUG_LOG(REPL, "+rps_carbrepl_next_token#" << callnum << " from "
                << __FILE__ << ":" << lin
                << " tksrc=" << *tksrc << "@" << (void*)tksrc << std::endl
                << Rps_Do_Output([&](std::ostream& out)
  {
    tksrc->display_current_line_with_cursor(out);
  })
      << std::endl
      << RPS_FULL_BACKTRACE_HERE(1, "rps_carbrepl_next_token+"));
  RPS_POSSIBLE_BREAKPOINT();
  _f.tokv = tksrc->lookahead_token(&_, 0);
  RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum << " from "
                << __FILE__ << ":" << lin
                << " tksrc=" << *tksrc
                << " tokv=" << _f.tokv);
  RPS_POSSIBLE_BREAKPOINT();
  if (!_f.tokv) {
    RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum << " from "
                  << __FILE__ << ":" << lin
                  << " tksrc=" << *tksrc
                  << " got end of file from " << std::endl
                  << RPS_FULL_BACKTRACE_HERE(1, "rps_carbrepl_next_token"));
    return RPSCARBREPL_EOF;     // should that be
                                // _RPSCARBREPL_END_OF_INPUT?
  };
  //////
  _f.kindtokob = _f.tokv.as_lextoken()->lxkind();
  _f.valtokv = _f.tokv.as_lextoken()->lxval();
  RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                << " from "
                << __FILE__ << ":" << lin
                << " tksrc=" << *tksrc << " tokv=" << _f.tokv
                << " of °kindtokob=" << _f.kindtokob
                << " and valtokv=" << _f.valtokv
		<< std::endl 
                << " from "
                << __FILE__ << ":" << lin);
  RPS_POSSIBLE_BREAKPOINT();
  _f.nextokv = tksrc->lookahead_token(&_, 1);
  RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum << " from "
                << __FILE__ << ":" << lin
                << " tksrc=" << *tksrc << std::endl
                << Rps_Do_Output([&](std::ostream& out)
  {
    tksrc->display_current_line_with_cursor(out);
  })
                << std::endl /// REPL debugging ⌣ rps_carbrepl_next_token
                << "+!tokv=" << _f.tokv
                << " nextokv=" << _f.nextokv
                << " tksrc=" << *tksrc << std::endl
                << RPS_FULL_BACKTRACE_HERE(1, "rps_carbrepl_next_token/b")
                << " currentline=" << Rps_QuotedC_String(tksrc->current_line())
                << " at " << tksrc->position_str());
  if (_f.kindtokob == RPS_ROOT_OB(_2A2mrPpR3Qf03p6o5b)) //int∈class
    {
      RPS_POSSIBLE_BREAKPOINT();
      RPS_ASSERT(_f.valtokv.is_int());
      gdb_do_return = true;
      gdb_returned = RPSCARBREPL_INT;
      RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                    << " gives INT " << _f.valtokv);
      _Pragma("message \"rps_carbrepl_next_token should transmit value of INT\"");
    }
  RPS_POSSIBLE_BREAKPOINT(); /// GDB could set gdb_do_return & gdb_returned
  RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                << " °gdb_do_return at "
                << (void*)&gdb_do_return << " is "
                << (gdb_do_return?"SET":"CLEARED")
                << " gdb_returned at " << (void*)&gdb_returned
                << " is " << gdb_returned << " tokv=" << _f.tokv);
  RPS_POSSIBLE_BREAKPOINT(); /// GDB could set gdb_do_return & gdb_returned
  //// temporary trick to help debugging with GDB
  asm volatile (".global carbrepl_rps_issue; nop; carbrepl_rps_issue: nop; nop; nop");
  RPS_ASSERT(&gdb_do_return != nullptr);
  RPS_POSSIBLE_BREAKPOINT(); /// GDB could set gdb_do_return & gdb_returned
  //// for GDB
  if (gdb_do_return) {
    RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                  << "- tksrc=" << *tksrc << " tokv=" << _f.tokv
                  << " gdb_returned=" << gdb_returned);
    RPS_INFORMOUT("rps_carbrepl_next_token from#" << callnum
                  << "- lin=" << lin << " tokv=" << _f.tokv
                  << " GDB returning " << gdb_returned);
    return gdb_returned;
  }
  else {
    RPS_POSSIBLE_BREAKPOINT();
    RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                  << "- tksrc=" << *tksrc << std::endl
                  << "… tokv=" << _f.tokv
		  << " nextokv=" << _f.nextokv << std::endl
                  << "… no°gdb_do_return" << std::endl
                  << RPS_FULL_BACKTRACE_HERE(1, "rps_carbrepl_next_token-gdb"));
  };
  ////
  RPS_POSSIBLE_BREAKPOINT();
#warning unimplemented rps_carbrepl_next_token
  RPS_FATALOUT("unimplemented rps_carbrepl_next_token#" << callnum
               << " from "
               << __FILE__ << ":" << lin
               << std::endl << "… tksrc=" << *tksrc
               << std::endl
                << Rps_Do_Output([&](std::ostream& out)
  {
    tksrc->display_current_line_with_cursor(out);
  })
      << std::endl << "… tokv=" << _f.tokv);
} // end rps_carbrepl_next_token




void
rps_do_carburetta_tokensrc(Rps_CallFrame*callerframe, Rps_ObjectRef obenvarg,
                                Rps_TokenSource*tksrc)
{
  RPS_LOCALFRAME(/*descr:*/RPS_ROOT_OB(_4CZZ2JlnkQT02YJ6sM), //replnt_command∈symbol
                 callerframe,
                 Rps_ObjectRef obenv;
                );
  _Pragma("message \"rps_do_carburetta_tokensrc\"");
  RPS_ASSERT(tksrc);
  _f.obenv = obenvarg;
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_tokensrc starting obenv="
		<< _f.obenv
                << " tksrc=" << *tksrc << "@" << (void*)tksrc
                << " FROM thread " << rps_current_pthread_name()
                << RPS_FULL_BACKTRACE_HERE(1, "start rps_do_carburetta_tokensrc")
                << std::endl);
  RPS_POSSIBLE_BREAKPOINT();
  struct rpscarbrepl_stack carbstack;
  struct rps_carbrepl_data_st carbdata;
  memset ((void*)&carbstack, 0, sizeof(carbstack));
  memset ((void*)&carbdata, 0, sizeof(carbdata));
  carbdata.cardata_magic = rps_magic_carbrepl_data;
  rpscarbrepl_stack_init(&carbstack);
  _.set_additional_gc_marker([&](Rps_GarbageCollector*gc) {
    RPS_ASSERT(gc != nullptr);
    rpscarbrepl_stack_visit(&carbstack, gc, &carbdata);
    gc->mark_obj(carbdata.cardata_ob1);
    gc->mark_obj(carbdata.cardata_ob2);
    gc->mark_obj(carbdata.cardata_obdelim);
    gc->mark_obj(carbdata.cardata_obop);
    gc->mark_value(carbdata.cardata_v1);
    gc->mark_value(carbdata.cardata_v2);
    gc->mark_value(carbdata.cardata_vleft);
    gc->mark_value(carbdata.cardata_vright);
    gc->mark_value(carbdata.cardata_vinst);
    });
  RPS_ASSERT(callerframe && callerframe->is_good_call_frame());
  RPS_POSSIBLE_BREAKPOINT();
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_tokensrc obenv=" << _f.obenv
                << " tksrc=" << *tksrc);
  RPS_POSSIBLE_BREAKPOINT();
#warning check this
  int r = rpscarbrepl_parse(&carbstack, /*sym:*/RPSCARBREPL_REPLNT_INPUT, tksrc, &_, carbdata);
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_tokensrc after rpscarbrepl_parse r=" << r
                << " obenv=" << _f.obenv
                << " tksrc=" << *tksrc);
#warning unimplemented rps_do_carburetta_tokensrc
  /// TODO: should probably use generated scanning routines
  /// the last statement should be the following cleanup
  rpscarbrepl_stack_cleanup(&carbstack);
  RPS_POSSIBLE_BREAKPOINT();
} // end rps_do_carburetta_tokensrc



void
rps_do_carburetta_command(Rps_CallFrame*callerframe, Rps_ObjectRef obenvarg, Rps_TokenSource*ptoksrc)
{
  RPS_LOCALFRAME(/*descr:*/RPS_ROOT_OB(_4CZZ2JlnkQT02YJ6sM), //replnt_command∈symbol
                 callerframe,
                 Rps_ObjectRef obenv;
                );
  _Pragma("message \"rps_do_carburetta_command\"");
  _f.obenv = obenvarg;
  RPS_ASSERT(callerframe && callerframe->is_good_call_frame());
  RPS_ASSERT(ptoksrc != nullptr);
  RPS_POSSIBLE_BREAKPOINT();
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_command start *ptoksrc=" << *ptoksrc
                << " obenv=" << RPS_OBJECT_DISPLAY(_f.obenv) << std::endl
                << RPS_FULL_BACKTRACE_HERE(1, "rps_do_carburetta_command start"));
  bool gotlin = ptoksrc->get_line();
  RPS_POSSIBLE_BREAKPOINT();
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_command before rps_do_carburetta_tokensrc *ptoksrc="
                << *ptoksrc << " " << (gotlin?"got line":"NO line"));
  RPS_POSSIBLE_BREAKPOINT();
  rps_do_carburetta_tokensrc(&_, _f.obenv, ptoksrc);
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_command end *ptoksrc=" << *ptoksrc
                << " obenv=" << _f.obenv << std::endl
                << RPS_FULL_BACKTRACE_HERE(1, "rps_do_carburetta_command end"));
}  // end rps_do_carburetta_command



 void
 rps_carbrepl_do_display_command(Rps_CallFrame*callerframe, Rps_ObjectRef obenvarg, Rps_Value exprarg)
 {
   RPS_LOCALFRAME(RPS_ROOT_OB(_006mAbXTG4G00QR5HS), ///display∈symbol h:2127571271
                  callerframe,
                  Rps_ObjectRef obenv;
                  Rps_Value exprv;
                 );
   _f.obenv = obenvarg;
   _f.exprv = exprarg;
  RPS_ASSERT(callerframe && callerframe->is_good_call_frame());
  RPS_DEBUG_LOG(REPL, "rps_carbrepl_do_display_command starting obenv="
                << RPS_OBJECT_DISPLAY(_f.obenv) << std::endl
                << " expr=" << _f.exprv);
  RPS_POSSIBLE_BREAKPOINT();
  RPS_DEBUG_LOG(CMD, "carburetta display obenv=" << RPS_OBJECT_DISPLAY(_f.obenv) << std::endl
                << "display expr=" << _f.exprv
                << std::endl
                << RPS_FULL_BACKTRACE_HERE(1, "carburetta command display"));
  RPS_POSSIBLE_BREAKPOINT();
#warning incomplete rps_do_display_carburetta_command
  // TODO: should evaluate exprv in obenv and display it
  RPS_WARNOUT("incomplete rps_carbrepl_do_display_command obenv=" << _f.obenv << " exprv=" << _f.exprv);
 } // end rps_carbrepl_do_display_command


static void
rps_carburetta_fill_delimiter(Rps_ObjectRef obdelim, int num, int line)
{
  RPS_ASSERT(obdelim);
  RPS_ASSERT(line > __LINE__);
  Rps_ObjectRef obcarbterm = rpskob_1cUbHIFNNXi00HOCWM /*carburetta_terminal*/;
  Rps_Value atv = obdelim->get_physical_attr(obcarbterm/*carburetta_terminal*/);
  if (atv != Rps_Value::make_tagged_int(num)) {
    obdelim->put_attr(obcarbterm,
		      Rps_Value::make_tagged_int(num));
    RPS_DEBUG_LOG(REPL, "rps_carburetta_fill_delimiter filled from "
		  << __FILE__ << ":" << line
		  << " delimiter " << std::endl
		  << RPS_OBJECT_DISPLAY(obdelim));
  }
  else
    RPS_DEBUG_LOG(REPL, "rps_carburetta_fill_delimiter good " << obdelim
		  << __FILE__ << ":" << line);
} // end rps_carburetta_fill_delimiter

void
rps_initialize_carburetta_after_load(Rps_Loader*ld)
{
  RPS_ASSERT(ld);
#define RPS_CARBURETTA_DELIM(Ob,Num) \
  rps_carburetta_fill_delimiter((Ob),(Num),__LINE__)
  RPS_CARBURETTA_DELIM
    (rpskob_7LMYzEqjeDH00ZI1CO,//$at_sign∈repl_delimiter h:150658742
     RPSCARBREPL_ATSIGN);
  RPS_CARBURETTA_DELIM
  (rpskob_4YM7mv0GrSp03OkF8T, //!leftparen!delim∈repl_delimiter
   RPSCARBREPL_LEFTPAREN);
  RPS_CARBURETTA_DELIM
    (rpskob_7CG9m1NXpMo01edTUl, //!rightparen!delim∈repl_delimiter
     RPSCARBREPL_RIGHTPAREN);
  RPS_CARBURETTA_DELIM
    (rpskob_78wsBiJhJj1025DIs1, //!!dot!delim∈repl_delimiter 
     RPSCARBREPL_DOT);
  RPS_CARBURETTA_DELIM
    (rpskob_4YM7mv0GrSp03OkF8T, //!!leftparen!delim∈repl_delimiter
     RPSCARBREPL_LEFTPAREN);
  RPS_CARBURETTA_DELIM
    (rpskob_7CG9m1NXpMo01edTUl, //!!rightparen!delim∈repl_delimiter
     RPSCARBREPL_RIGHTPAREN);
#if 0
  RPS_CARBURETTA_DELIM
    (rpskob_6kHcxtGAtWW03dZ14O, //!!$leftbrace!delim∈repl_delimiter 
     RPSCARBREPL_LEFTBRACE);
  RPS_CARBURETTA_DELIM
    (rpskob_68wsAiJhJj1025DIs1, //!!$rightbrace!delim∈repl_delimiter 
     RPSCARBREPL_RIGHTBRACE);
#endif
#undef RPS_CARBURETTA_DELIM
  RPS_DEBUG_LOG(REPL, "initialize°carburetta done");
#warning incomplete rps_initialize_carburetta_after_load
  RPS_WARNOUT("incomplete rps_initialize_carburetta_after_load"
              << std::endl
              << RPS_FULL_BACKTRACE_HERE(1, "rps_initialize_carburetta_after_load"));
} // end rps_initialize_carburetta_after_load


const char*
rps_carbrepl_symname_at(int symnum, int lin) {
//// https://github.com/kingletbv/carburetta/issues/9
  RPS_POSSIBLE_BREAKPOINT();
  if (symnum>0 && symnum<rpscarbrepl_symbol_names_length_
      && rpscarbrepl_symbol_names_[symnum]) {
    RPS_DEBUG_LOG(REPL, "°carbrepl_symname symnum#" << symnum
                  << " lin:" << lin
                  << " is "
                  << rpscarbrepl_symbol_names_[symnum]);
    return rpscarbrepl_symbol_names_[symnum];
  }
  else {
    RPS_WARNOUT("°carbrepl_symname bad symnum#" << symnum
                  << " lin:" << lin
		<< RPS_FULL_BACKTRACE_HERE(1, "carbrepl_symname/BAD"));
    RPS_POSSIBLE_BREAKPOINT();
    static char buf[32];
    memset (buf, 0, sizeof(buf));
    snprintf(buf, sizeof(buf), "*BADSYM%d@%d*", symnum, lin);
    return buf;
  }
} // end rps_carbrepl_symname_at

////////////////////////////////////////////////////////////////
extern "C" const char rps_carbrepl_gitid[];
const char rps_carbrepl_gitid[]= RPS_GITID;

extern "C" const char rps_carbrepl_date[];
const char rps_carbrepl_date[]= __DATE__;

extern "C" const char rps_carbrepl_shortgitid[];
const char rps_carbrepl_shortgitid[]= RPS_SHORTGITID;

extern "C" const size_t rpscarbrepl_stack_size;
extern "C" const size_t rpscarbrepl_stack_align;

const size_t rpscarbrepl_stack_size = sizeof(struct rpscarbrepl_stack);
const size_t rpscarbrepl_stack_align = alignof(struct rpscarbrepl_stack);
/****************
 **                           for Emacs...
 ** Local Variables: ;;
 ** mode: c++ ;;
 ** compile-command: "make _carbrepl_rps.o && make" ;;
 ** End: ;;
 ****************/
