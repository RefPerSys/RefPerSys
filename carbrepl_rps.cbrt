/****************************************************************
 * file carbrepl_rps.cbrt
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 * Description:
 *      This file is part of the Reflective Persistent System.
 *      It is its Carburetta grammar and parser
 *      see https://carburetta.com/
 *      It should be processed by at least carburetta 0.8.27 (mid-july 2025)
 *
 * Author(s):
 *      Basile Starynkevitch, France   <basile@starynkevitch.net>
 *
 *      © Copyright 2025 The Reflective Persistent System Team
 *      team@refpersys.org & http://refpersys.org/
 *
 * License: GPLv3+ (file COPYING-GPLv3)
 *    This software is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version. NO WARRANTY
 ****************************************************************/

#include "refpersys.hh"
#pragma message "prologue part of carbrepl_rps.cbrt"

#ifndef RPS_GITID
#error RPS_GITID is not defined by compilation command
#endif

extern "C" const char rps_carbrepl_gitid[];
const char rps_carbrepl_gitid[]= RPS_GITID;

extern "C" const char rps_carbrepl_date[];
const char rps_carbrepl_date[]= __DATE__;

extern "C" const char rps_carbrepl_shortgitid[];
const char rps_carbrepl_shortgitid[]= RPS_SHORTGITID;

extern "C" const char rps_carbrepl_timestamp[];
const char rps_carbrepl_timestamp[]= __TIMESTAMP__;

constexpr unsigned rps_magic_carbrepl_data = 696140743; // 0x297e43c7
struct rps_carbrepl_data_st {
  unsigned cardata_magic;       // always  rps_magic_carbrepl_data
  unsigned cardata_touchline;
  double cardata_mtime;		// elapsed realtime
  intptr_t cardata_i;
  double cardata_d;
  std::string cardata_str;
  void* cardata_ptr;
  Rps_ObjectRef cardata_ob1;
  Rps_ObjectRef cardata_ob2;
  Rps_ObjectRef cardata_obdelim;
  Rps_ObjectRef cardata_obop;
  Rps_Value cardata_v1;
  Rps_Value cardata_v2;
  Rps_Value cardata_vleft;
  Rps_Value cardata_vright;
  Rps_InstanceValue cardata_vinst;
  inline void touch_carbdata(int li=__builtin_LINE());
  inline void reset_carbdata(int li=__builtin_LINE());
};


void
rps_carbrepl_data_st::touch_carbdata(int lin)
{
  RPS_ASSERT(cardata_magic == rps_magic_carbrepl_data);
  RPS_ASSERT(lin>0);
  cardata_touchline=lin;
  cardata_mtime=rps_elapsed_real_time();
  RPS_DEBUG_LOG(REPL, "touching carbrepl_data@" << (void*)this << " line#" << lin);
} // end rps_carbrepl_data_st::touch_carbdata


void
rps_carbrepl_data_st::reset_carbdata(int lin)
{
  RPS_ASSERT(cardata_magic == rps_magic_carbrepl_data);
  RPS_ASSERT(lin>0);
  cardata_i = 0;
  cardata_d = 0.0;
  cardata_str.erase();
  memset((void*)&cardata_ptr, 0,
         sizeof(*this)-offsetof(rps_carbrepl_data_st, cardata_ptr));
  RPS_ASSERT(cardata_magic == rps_magic_carbrepl_data);
  cardata_touchline=lin;
  cardata_mtime=rps_elapsed_real_time();
  RPS_DEBUG_LOG(REPL, "resetting carbrepl_data@" << (void*)this << " line#" << lin);
} // end rps_carbrepl_data_st::reset_carbdata

extern "C" int rps_carbrepl_keyword_lexer(Rps_CallFrame*,const std::string&keystr,Rps_ObjectRef obkw);
extern "C" void rps_carbrepl_do_display_command(Rps_CallFrame*callframe, Rps_ObjectRef obenv, Rps_Value expr);
static void rps_carbrepl_constructor_replnt_object(Rps_ObjectRef&obr, int lin);
static void rps_carbrepl_destructor_replnt_object(Rps_ObjectRef&obr, int lin);
static const char* rps_carbrepl_symname_at(int symnum, int lin);
#define  RPS_CARBREPL_SYMBOL_NAME(Num) rps_carbrepl_symname_at(Num, __LINE__)


static void rps_carbrepl_constructor_replnt_atom(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_atom(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_set(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_set(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_expr(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_expr(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_factor(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_factor(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_term(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_term(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_value(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_value(Rps_Value&val, int lin);
struct rps_carbrepl_data_st;


/// this is used by %on_next_token
/***
When the parser (not the scanner) needs a new input terminal symbol, the specified action code snippet is executed.

If the directive is not specified, the default behavior is to return <prefix>FEED_ME.

A valid use-case for %on_next_token is to feed the parser with a new symbol by storing its ordinal value in sym without returning to the caller
****/

extern "C" int rps_carbrepl_next_token(Rps_CallFrame*callframe, Rps_TokenSource*tksrc, int& sym, struct rps_carbrepl_data_st&carbdata, int lin);
int rps_carbrepl_next_token(Rps_CallFrame*callframe, Rps_TokenSource*tksrc, int& sym, struct rps_carbrepl_data_st&carbdata, int lin);

extern "C" struct rpscarbrepl_stack;

/// The following is related to the the visitor facility in carburetta 0.8.25 or newer (april 2025)
/// See https://github.com/kingletbv/carburetta/issues/4
extern "C" void rps_carbrepl_garbage_collect_visit_stack(struct rpscarbrepl_stack*,Rps_GarbageCollector*);
%visit_params Rps_GarbageCollector*visitgc, rps_carbrepl_data_st*carbdata


%header%
#pragma message "header part of carbrepl_rps.cbrt"
extern "C" const char rps_carbrepl_gitid[];
extern "C" const char rps_carbrepl_date[];
extern "C" const char rps_carbrepl_shortgitid[];
%%

%prefix rpscarbrepl_
//forbidden %token_action here since it must follow %token_type, %type, %class, %common_type or %common_class directive
%end_token EOF

%token ATSIGN
 //ATSIGN being untyped cannot have a token_action

%token INT
%type INT: intptr_t
%token_action {  _Pragma("message \"token_action for INT\"");           \
  $$ = carbdata.cardata_i;                                              \
  RPS_DEBUG_LOG(REPL, "token_action for INT tksrc=" << *tksrc           \
                << " cardata_i=" << carbdata.cardata_i);                \
  RPS_FATALOUT("INT token_action is incomplete tksrc="                  \
               << tksrc << " sym=" << sym                               \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)                  \
               << RPS_FULL_BACKTRACE(1, "token_action INT"));      \
 }


%token DOUBLE
%type DOUBLE: double
%token_action {  _Pragma("message \"token_action for DOUBLE\"");        \
  RPS_DEBUG_LOG(REPL, "token_action for DOUBLE tksrc=" << *tksrc        \
                << " cardata_d=" << carbdata.cardata_d);                \
  /* should assign $$ for DOUBLE */                                     \
  $$ = carbdata.cardata_d;                                              \
  RPS_FATALOUT("DOUBLE token_action is incomplete tksrc="               \
               << tksrc << " sym=" << sym                               \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)                  \
               << " cardata_d="   << carbdata.cardata_d                 \
               << RPS_FULL_BACKTRACE(1, "token_action DOUBLE"));   \
 }

%token STRING
%type STRING: std::string
%token_action { _Pragma("message \"token_action for STRING\"");         \
  /*  assign $$ for STRING */                                   \
  RPS_DEBUG_LOG(REPL, "token_action for STRING tksrc=" << *tksrc        \
                << " cardata_str="                                      \
                << Rps_QuotedC_String(carbdata.cardata_str));           \
  $$ = carbdata.cardata_str;                                            \
  RPS_FATALOUT("STRING token_action is incomplete tksrc=" << tksrc      \
               << " sym=" << sym                                        \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)                  \
               << RPS_FULL_BACKTRACE(1, "token_action STRING"));   \
 }

%token NAME
%type NAME: std::string
%token_action {  _Pragma("message \"token_action for NAME\"");          \
  RPS_DEBUG_LOG(REPL, "token_action for NAME tksrc=" << *tksrc          \
                << " cardata_str=" << carbdata.cardata_str);            \
  /* should assign $$ for NAME using cardata_str */                     \
  RPS_FATALOUT("NAME token_action is incomplete tksrc=" << tksrc        \
               << " sym=" << sym                                        \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)                  \
                << " cardata_str=" << carbdata.cardata_str              \
               << std::endl                                             \
               << RPS_FULL_BACKTRACE(1, "token_action NAME"));     \
 }

%token OID
%type OID: Rps_Id
%token_action { _Pragma("message \"token_action for OID\"");            \
  /* should assign $$ for OID */                                        \
  RPS_DEBUG_LOG(REPL, "token_action for OID tksrc=" << *tksrc           \
                << " cardata_str=" << carbdata.cardata_str);            \
  RPS_FATALOUT("OID token_action is incomplete tksrc=" << tksrc         \
               << " sym=" << sym                                        \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)                  \
               << RPS_FULL_BACKTRACE(1, "token_action NAME"));     \
 }




//// Adding new KEYW_ keywords could require to create a symbol for them using
/***
 ./refpersys --plugin-after-load=/tmp/rpsplug_createsymbol.so \
 --plugin-arg=rpsplug_createsymbol:<SYMBOL> \
 --extra=comment='<SYMBOL> symbol for carburetta keyword' \
 --extra=rooted=0 \
 --extra=constant=1 \
 --batch --dump=.
***/
////
%token KEYW_DISPLAY
%token_action { _Pragma("message \"token_action for KEYW_DISPLAY\"");    \
  RPS_DEBUG_LOG(REPL, "token_action for KEYW_DISPLAY tksrc=" << *tksrc   \
                << " sym=" << sym << "::"                                \
                << RPS_CARBREPL_SYMBOL_NAME(sym));                       \
  /* should assign $$ for KEYW_DISPLAY */                                \
  RPS_FATALOUT("KEYW_DISPLAY token_action is incomplete tksrc="          \
               << tksrc << " sym=" << sym                                \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)                   \
               << RPS_FULL_BACKTRACE(1,                             \
                                          "token_action KEYW_DISPLAY")); \
 }

%token KEYW_OBJECT
%token_action { _Pragma("message \"token_action for KEYW_OBJECT\"");    \
  RPS_DEBUG_LOG(REPL, "token_action for KEYW_OBJECT tksrc=" << *tksrc   \
                << " sym=" << sym << "::"                               \
                << RPS_CARBREPL_SYMBOL_NAME(sym));                      \
  /* should assign $$ for KEYW_OBJECT */                                \
  RPS_FATALOUT("KEYW_OBJECT token_action is incomplete tksrc=" << tksrc \
               << " sym=" << sym                                        \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)                  \
               << RPS_FULL_BACKTRACE(1,                            \
                                          "token_action KEYW_OBJECT")); \
 }

%token KEYW_PUT
%token_action { _Pragma("message \"token_action for KEYW_PUT\"");       \
  RPS_DEBUG_LOG(REPL, "token_action for KEYW_PUT tksrc=" << *tksrc);    \
  /* should assign $$ for KEYW_PUT */                                   \
  RPS_FATALOUT("KEYW_OBJECT token_action is incomplete tksrc=" << tksrc \
               << " sym=" << sym                                        \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)                  \
               << RPS_FULL_BACKTRACE(1,                            \
                                          "token_action KEYW_PUT"));    \
 }
 

%token DOT
%token_action { _Pragma("message \"token_action for DOT\""); \
  /* should assign $$ for DOT */ \
  RPS_DEBUG_LOG(REPL, "token_action for DOT tksrc=" << *tksrc); \
  RPS_FATALOUT("DOT token_action is incomplete tksrc=" \
               << tksrc << " sym=" << sym              \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE(1, "token_action DOT"));      \
 }

%token COMMA
%token_action { _Pragma("message \"token_action for COMMA\""); \
  /* should assign $$ for COMMA */ \
  RPS_DEBUG_LOG(REPL, "token_action for COMMA tksrc=" << *tksrc); \
  RPS_FATALOUT("COMMA token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE(1, "token_action COMMA"));      \
 }

%token ASSIGN
%token_action {_Pragma("message \"token_action for ASSIGN\""); \
  /* should assign $$ for ASSIGN */ \
  RPS_DEBUG_LOG(REPL, "token_action for ASSIGN tksrc=" << *tksrc); \
  RPS_FATALOUT("ASSIGN token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE(1, "token_action ASSIGN"));   \
 }

%token LEFTPAREN
%token_action {_Pragma("message \"token_action for LEFTPAREN\""); \
  /* should assign $$ for LEFTPAREN */ \
  RPS_DEBUG_LOG(REPL, "token_action for LEFTPAREN tksrc=" << *tksrc); \
  RPS_FATALOUT("LEFTPAREN token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE(1, "token_action LEFTPAREN"));        \
 }

%token RIGHTPAREN
%token_action {_Pragma("message \"token_action for RIGHTPAREN\""); \
  RPS_DEBUG_LOG(REPL, "token_action for RIGHTPAREN tksrc=" << *tksrc); \
  /* should assign $$ for RIGHTPAREN */ \
  RPS_FATALOUT("RIGHTPAREN token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE(1, "token_action RIGHTPAREN"));       \
 }
//


%token LEFTBRACE
%token_action {_Pragma("message \"token_action for LEFTBRACE\""); \
  /* should assign $$ for LEFTBRACE */ \
  RPS_DEBUG_LOG(REPL, "token_action for LEFTBRACE tksrc=" << *tksrc); \
  RPS_FATALOUT("LEFTBRACE token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE(1, "token_action LEFBRACE"));        \
 }

%token RIGHTBRACE
%token_action {_Pragma("message \"token_action for RIGHTBRACE\""); \
  RPS_DEBUG_LOG(REPL, "token_action for RIGHTBRACE tksrc=" << *tksrc); \
  /* should assign $$ for RIGHTBRACE */ \
  RPS_FATALOUT("RIGHTBRACE token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE(1, "token_action RIGHTBRACE"));       \
 }
//

%token PLUS 
%token_action {_Pragma("message \"token_action for PLUS\""); \
  /* should assign $$ PLUS */ \
  RPS_DEBUG_LOG(REPL, "token_action for PLUS tksrc=" << *tksrc); \
  RPS_FATALOUT("PLUS token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE(1, "token_action PLUS"));     \
 }
//

%token MINUS 
%token_action {_Pragma("message \"token_action for MINUS\""); \
  RPS_DEBUG_LOG(REPL, "token_action for MINUS tksrc=" << tksrc); \
  /* should assign $$ MINUS */ \
  RPS_FATALOUT("MINUS token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE(1, "token_action MINUS"));    \
 }
//


%token ASTERISK 
%token_action {_Pragma("message \"token_action for ASTERISK\""); \
  RPS_DEBUG_LOG(REPL, "token_action for ASTERISK tksrc=" << *tksrc); \
  /* should assign $$ ASTERISK */ \
  RPS_FATALOUT("ASTERISK token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE(1, "token_action ASTERISK")); \
 }
//

%token SLASH 
%token_action {_Pragma("message \"token_action for SLASH\""); \
  RPS_DEBUG_LOG(REPL, "token_action for SLASH tksrc=" << *tksrc); \
  /* should assign $$ SLASH */ \
  RPS_FATALOUT("SLASH token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
               << ":" << RPS_CARBREPL_SYMBOL_NAME(sym) \
               << RPS_FULL_BACKTRACE(1, "token_action SLASH"));    \
 }
//

%grammar%
%params Rps_TokenSource* tksrc, Rps_CallFrame* callframe, rps_carbrepl_data_st&carbdata
%nt replnt_input replnt_command
%nt replnt_atom replnt_object replnt_expr replnt_term replnt_factor
%nt replnt_value replnt_set replnt_objectseq replnt_restobjectseq


%type replnt_objectseq: Rps_ObjectVector

%type replnt_restobjectseq: Rps_ObjectVector


// When the parser (not the scanner) needs a new input terminal symbol, the specified action code snippet is executed.
// we probably need to use Rps_TokenSource::lookahead_token
%on_next_token {_Pragma("message \"on_next_token code\"");              \
    RPS_POSSIBLE_BREAKPOINT();                                          \
    RPS_DEBUG_LOG(REPL, "°+on_next_token start tksrc=" << *tksrc        \
                  << " sym:" << sym                                     \
                  << ":" << RPS_CARBREPL_SYMBOL_NAME(sym)               \
                  << std::endl                                          \
                  << RPS_FULL_BACKTRACE(1, "¤+on_next_token"));    \
    RPS_POSSIBLE_BREAKPOINT();                                          \
    _Pragma("message \"FIXME the value of next token\"");               \
    int ntk = rps_carbrepl_next_token(callframe, tksrc, sym,            \
                                      carbdata,                         \
                                      __LINE__);                        \
    RPS_DEBUG_LOG(REPL, "°-on_next_token tksrc=" << *tksrc << " is "    \
                  << ntk << "::" << RPS_CARBREPL_SYMBOL_NAME(ntk)       \
                  << " sym:" << sym                                     \
                  << std::endl                                          \
                  << RPS_FULL_BACKTRACE(1, "¤-on_next_token"));    \
    return ntk; }



%type replnt_object: Rps_ObjectRef
%constructor rps_carbrepl_constructor_replnt_object($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_object($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_object\"");RPS_ASSERT(visitgc);$$->gc_mark(*visitgc);}

%type replnt_atom: Rps_Value
%constructor rps_carbrepl_constructor_replnt_atom($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_atom($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_atom\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}


%type replnt_expr: Rps_Value
%constructor rps_carbrepl_constructor_replnt_expr($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_expr($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_expr\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}



%type replnt_term: Rps_Value
%constructor rps_carbrepl_constructor_replnt_term($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_term($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_term\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}



%type replnt_factor: Rps_Value
%constructor rps_carbrepl_constructor_replnt_factor($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_factor($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_factor\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}


%type replnt_value: Rps_Value
%constructor rps_carbrepl_constructor_replnt_value($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_value($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_value\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}


%type replnt_input: int
%type replnt_command: int


/* the start symbol is the first non-terminal */
replnt_input: EOF {
  _Pragma("message \"replnt_input as EOF in carbrepl_rps.cbrt\"");
  RPS_ASSERT("empty replnt_input" && tksrc != nullptr);
  RPS_DEBUG_LOG(REPL, "replnt_input as EOF tksrc=" << *tksrc); \
  RPS_ASSERT(callframe != nullptr && callframe->is_good_call_frame());
  $$ = 0;
}

replnt_input: replnt_command replnt_input {
   _Pragma("message \"replnt_input as replnt_command replnt_input in carbrepl_rps.cbrt\"");
   RPS_ASSERT("command replnt_input" && tksrc != nullptr);
   RPS_ASSERT(callframe != nullptr && callframe->is_good_call_frame());
   RPS_ASSERT(tksrc != nullptr);
   $$ = $1 + 1;
}

replnt_command: ATSIGN KEYW_DISPLAY replnt_expr {
   _Pragma("message \"replnt_command as KEYW_DISPLAY replnt_expr in carbrepl_rps.cbrt\"");
   RPS_DEBUG_LOG(REPL, "display carburetta command $2 is:" << $2
		 << RPS_FULL_BACKTRACE(1, "display carburetta command"));
   RPS_ASSERT(callframe != nullptr && callframe->is_good_call_frame());
   RPS_ASSERT(tksrc != nullptr);
   RPS_POSSIBLE_BREAKPOINT();
   rps_carbrepl_do_display_command(callframe, rps_get_first_repl_environment(), $2);
   RPS_POSSIBLE_BREAKPOINT();
   tksrc->clear_token_dequeue();
   RPS_POSSIBLE_BREAKPOINT();
   $$ = 1;
}

replnt_command: ATSIGN KEYW_PUT replnt_object DOT replnt_object ASSIGN replnt_expr {
   _Pragma("message \"replnt_command as KEYW_PUT replnt_object DOT replnt_object ASSIGN replnt_expr in carbrepl_rps.cbrt\"");
   RPS_DEBUG_LOG(REPL, "put carburetta command $2 is:" << $2 << ", attr $4 is " << $4 << ", expr $6 is " << $6);
   RPS_POSSIBLE_BREAKPOINT();
   RPS_ASSERT(callframe != nullptr && callframe->is_good_call_frame());
   RPS_ASSERT(tksrc != nullptr);
   tksrc->clear_token_dequeue();
   RPS_POSSIBLE_BREAKPOINT();
   $$ = 1;
}

replnt_command: error {
  RPS_POSSIBLE_BREAKPOINT();
  RPS_WARNOUT("invalid syntax for command tksrc=" << tksrc);
  RPS_POSSIBLE_BREAKPOINT();
  $$ = 0;
}

replnt_atom: INT {
_Pragma("message \"replnt_atom as INT in carbrepl_rps.cbrt\"");
 RPS_POSSIBLE_BREAKPOINT();
  $$ = Rps_Value::make_tagged_int($0);
  RPS_DEBUG_LOG(REPL, "atom is INT " << $$ << " from integer " << $0);
}

replnt_atom: DOUBLE {
_Pragma("message \"replnt_atom as DOUBLE in carbrepl_rps.cbrt\"");
  $$ = Rps_DoubleValue($0);
  RPS_DEBUG_LOG(REPL, "atom is DOUBLE " << $$ << " from double " << $0);
}

replnt_atom: STRING {
_Pragma("message \"replnt_atom as STRING in carbrepl_rps.cbrt\"");
  $$ = Rps_StringValue($0);
  RPS_DEBUG_LOG(REPL, "atom is STRING " << $$ << " from string " << Rps_QuotedC_String($0));
}

replnt_atom: replnt_object {
  _Pragma("message \"replnt_atom as replnt_object in carbrepl_rps.cbrt\"");
  $$ = Rps_ObjectValue($0);
  RPS_DEBUG_LOG(REPL, "atom is object " << $$);
}

replnt_atom: replnt_set {
_Pragma("message \"replnt_atom as replnt_set in carbrepl_rps.cbrt\"");
 RPS_POSSIBLE_BREAKPOINT();
 $$ = Rps_SetValue($0);
 RPS_DEBUG_LOG(REPL, "atom is set " << $$);
}

%type replnt_set: Rps_SetValue

replnt_set: LEFTBRACE replnt_objectseq RIGHTBRACE {
_Pragma("message \"replnt_set in carbrepl_rps.cbrt\"");
 RPS_POSSIBLE_BREAKPOINT();
 $$ = Rps_SetValue($1);
  RPS_DEBUG_LOG(REPL, "set " << $$);
}

replnt_objectseq: /*empty*/ {
_Pragma("message \"replnt_objectseq empty in carbrepl_rps.cbrt\"");
 RPS_POSSIBLE_BREAKPOINT();
 $$ = Rps_ObjectVector();
 RPS_DEBUG_LOG(REPL, "empty objectseq " << $$);
}

replnt_objectseq: replnt_object replnt_restobjectseq {
 $$ = Rps_ObjectVector();
 $$.reserve($1.size()+2);
 $$.push_back($0);
 for (Rps_ObjectRef compob: $1)
   $$.push_back(compob);
 RPS_DEBUG_LOG(REPL, "replnt_objectseq is " << $$);
}

replnt_restobjectseq: /*empty*/ {
_Pragma("message \"replnt_restobjectseq empty in carbrepl_rps.cbrt\"");
 RPS_POSSIBLE_BREAKPOINT();
 $$ = Rps_ObjectVector();
 RPS_DEBUG_LOG(REPL, "empty restobjectseq " << $$);
}

replnt_restobjectseq: COMMA replnt_objectseq {
_Pragma("message \"replnt_restobjectseq with comma in carbrepl_rps.cbrt\"");
 RPS_POSSIBLE_BREAKPOINT();
 $$ = $1;
 RPS_DEBUG_LOG(REPL, "comma restobjectseq " << $$);
}

replnt_object: NAME {
  _Pragma("message \"replnt_object as NAME in carbrepl_rps.cbrt\"");
  $$ = Rps_PayloadSymbol::find_named_object($0);
  RPS_DEBUG_LOG(REPL, "object is name " << $$ << " from name " << Rps_QuotedC_String($0));
}

replnt_object: OID {
  _Pragma("message \"replnt_object as OID in carbrepl_rps.cbrt\"");
  $$ = Rps_ObjectRef::really_find_object_by_oid($0);
  RPS_DEBUG_LOG(REPL, "object is oid " << $$ << " from oid " << $0);
}


replnt_expr: KEYW_OBJECT replnt_object {
  _Pragma("message \"replnt_expr as KEYW_OBJECT replnt_object in carbrepl_rps.cbrt\"");
  $$ = Rps_ObjectValue($1);
  RPS_DEBUG_LOG(REPL, "expr is object " << $$);
}


replnt_expr: replnt_term                      {
  _Pragma("message \"replnt_expr as replnt_term in carbrepl_rps.cbrt\"");
  RPS_DEBUG_LOG(REPL, "expr is term " << $$);
  $$ = $0;
}

replnt_expr: replnt_expr PLUS replnt_term            {            
  _Pragma("message \"replnt_expr as replnt_expr PLUS replnt_term in carbrepl_rps.cbrt\"");
  RPS_DEBUG_LOG(REPL, "expr is sum of " << $0 << " and " << $2);
  RPS_ASSERT(carbdata.cardata_magic == rps_magic_carbrepl_data);
  static Rps_Id id_plus_delim;
  if (!id_plus_delim)
    id_plus_delim = Rps_Id("_4ShDsOWk7al02eDRTM");
  static Rps_Id id_plus_binop;
  if (!id_plus_binop)
    id_plus_binop = Rps_Id("_51jvc2mFhql03qwRg6");
  carbdata.cardata_obdelim =
    Rps_ObjectRef::find_object_or_fail_by_oid(callframe,
                                              id_plus_delim); // "plus!delim"∈repl_delimiter
  carbdata.cardata_obop =
    Rps_ObjectRef::find_object_or_fail_by_oid(callframe,
                                              id_plus_binop); // "plus!binop"∈repl_binary_operator
  /// for the garbage collector we need to...
  carbdata.cardata_vleft = $0;
  carbdata.cardata_vright = $2;
  carbdata.touch_carbdata();
  _Pragma("message \"take inspiration from parsrepl_rps.cc function Rps_TokenSource::parse_sum\"");
  $$ = carbdata.cardata_vinst
    = Rps_InstanceValue(RPS_ROOT_OB(_55Z5Wgzuprq01MU6Br), //repl_binary_operator∈class h:2852622165
                        {carbdata.cardata_obop, $0, $2});
  RPS_DEBUG_LOG(REPL, "replnt_expr: replnt_expr PLUS replnt_term result is " << $$
		<< " obdelim=" << carbdata.cardata_obdelim
		<< " obop=" << carbdata.cardata_obop
                << " left:" << $0 << " right:" << $2 << std::endl
                << RPS_FULL_BACKTRACE(1, "replnt_expr: replnt_expr PLUS replnt_term"));
  //FIXME:carbdata.cardata_vinst->put_persistent_metadata(<some-object>,<some-integer>);
  carbdata.reset_carbdata();
}

replnt_expr: replnt_expr MINUS replnt_term           {
  _Pragma("message \"replnt_expr as replnt_expr MINUS replnt_term in carbrepl_rps.cbrt\"");
  static Rps_Id id_minus_delim;
  _Pragma("message \"wrong Ids for MINUS\"");
  if (!id_minus_delim)
    id_minus_delim = Rps_Id("_4ShDsOWk7al02eDRtM");  ///TODO: WRONG FIXME
  static Rps_Id id_minus_binop;
  if (!id_minus_binop)
    id_minus_binop = Rps_Id("_51jvc2mFhql03qwRG6");  ///TODO: WRONG FIXME
  carbdata.cardata_obdelim =
    Rps_ObjectRef::find_object_or_fail_by_oid(callframe,
                                              id_minus_delim); // "minus!delim"∈repl_delimiter
  RPS_ASSERT(carbdata.cardata_obdelim);
  carbdata.cardata_obop =
    Rps_ObjectRef::find_object_or_fail_by_oid(callframe,
                                              id_minus_binop); // "minus!binop"∈repl_binary_operator
  /// for the garbage collector we need to...
  carbdata.cardata_vleft = $0;
  carbdata.cardata_vright = $2;
  carbdata.touch_carbdata();
  // $$ = $0 - $2;
}
  
replnt_term: replnt_factor                    {
  _Pragma("message \"replnt_term as replnt_factor in carbrepl_rps.cbrt\"");
  $$ = $0;
}

replnt_term: replnt_term ASTERISK replnt_factor      {
  _Pragma("message \"replnt_term as replnt_term ASTERISK replnt_factor in carbrepl_rps.cbrt\"");
  //  $$ = $0 * $2;
  }

replnt_term: replnt_term SLASH replnt_factor         {
  _Pragma("message \"replnt_term as replnt_term SLASH replnt_factor in carbrepl_rps.cbrt\"");
  //  $$ = $0 / $2;
  }
  
replnt_factor: replnt_atom                   {
  _Pragma("message \"replnt_factor as replnt_atom in carbrepl_rps.cbrt\"");
  $$ = $0;
  RPS_DEBUG_LOG(REPL, "factor is atom " << $$);
  }

replnt_factor: MINUS replnt_factor            {
  _Pragma("message \"replnt_factor as MINUS replnt_factor in carbrepl_rps.cbrt\"");
  // $$ = -$1;
  }

replnt_factor: LEFTPAREN replnt_expr RIGHTPAREN {
  _Pragma("message \"replnt_factor as LEFTPAREN replnt_factor RIGHTPAREN in carbrepl_rps.cbrt\"");
  RPS_DEBUG_LOG(REPL, "factor is parenthesised expr " << $1);
  // $$ = $1;
  }



%%

/******
 * issue #10 of carburetta has been fixed by its commit 1b08a7cfec9563e1
 ******/
#pragma message "trailer of carbrepl_rps.cbrt"

//// for objects in REPL
void
rps_carbrepl_constructor_replnt_object(Rps_ObjectRef&obr, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  _Pragma("message \"rps_carbrepl_constructor_replnt_object\"");
  obr = nullptr;
} // end rps_carbrepl_constructor_replnt_object

void
rps_carbrepl_destructor_replnt_object(Rps_ObjectRef&obr, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  _Pragma("message \"rps_carbrepl_replnt_object_destructor\"");
  obr = nullptr;
} // end rps_carbrepl_replnt_object_destructor



//// for atoms in REPL
void
rps_carbrepl_constructor_replnt_atom(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_atom\"");
} // end rps_carbrepl_constructor_replnt_atom

void
rps_carbrepl_destructor_replnt_atom(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_atom\"");
} // end rps_carbrepl_replnt_object_destructor_replnt_atom


//// for sets in REPL
void
rps_carbrepl_constructor_replnt_set(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_set\"");
} // end rps_carbrepl_constructor_replnt_atom

void
rps_carbrepl_destructor_replnt_set(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_set\"");
} // end rps_carbrepl_replnt_object_destructor_replnt_set




//// for expressions in REPL
void
rps_carbrepl_constructor_replnt_expr(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_expr\"");
} // end rps_carbrepl_constructor_replnt_expr

void
rps_carbrepl_destructor_replnt_expr(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_expr\"");
} // end rps_carbrepl_replnt_destructor_replnt_expr

void
rps_carbrepl_constructor_replnt_term(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_term\"");
} // end rps_carbrepl_constructor_replnt_term

void
rps_carbrepl_destructor_replnt_term(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_term\"");
} // end rps_carbrepl_replnt_destructor_replnt_term

void
rps_carbrepl_constructor_replnt_factor(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_factor\"");
} // end rps_carbrepl_constructor_replnt_factor

void
rps_carbrepl_destructor_replnt_factor(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_factor\"");
} // end rps_carbrepl_replnt_destructor_replnt_factor

void
rps_carbrepl_constructor_replnt_value(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_value\"");
} // end rps_carbrepl_constructor_replnt_factor

void
rps_carbrepl_destructor_replnt_value(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_value\"");
} // end rps_carbrepl_replnt_destructor_replnt_value

int
rps_carbrepl_next_token(Rps_CallFrame*callframe, Rps_TokenSource*tksrc,
                        int& sym, struct rps_carbrepl_data_st&carbdata, int lin)
{
  static thread_local int callcnt;
  /// used by %on_next_token above:
#warning gdb_do_return and gdb_returned should become useless
  bool gdb_do_return=false; // to be set from GDB
  int gdb_returned= 0;      // to be set from GDB
  int callnum = ++callcnt;
  RPS_POSSIBLE_BREAKPOINT();
  RPS_LOCALFRAME(/*descr:*/RPS_ROOT_OB(_4CZZ2JlnkQT02YJ6sM), //replnt_command∈symbol
                           callframe,
                           Rps_ObjectRef obenv;
                           Rps_Value tokv;
                           Rps_ObjectRef kindtokob;
                           Rps_Value valtokv;
                           Rps_ObjectRef valtokob;
                           Rps_Value carbtermv;
                );
  RPS_ASSERT(tksrc);
  RPS_ASSERT(callframe && callframe->is_good_call_frame());
  RPS_DEBUG_LOG(REPL, "+rps_carbrepl_next_token#" << callnum << " from "
                << __FILE__ << ":" << lin
                << " tksrc=" << *tksrc << "@" << (void*)tksrc << std::endl
                << Rps_Do_Output([&](std::ostream& out)
                {
                  tksrc->display_current_line_with_cursor(out);
                })
                << std::endl
                << RPS_FULL_BACKTRACE(1, "rps_carbrepl_next_token+"));
  RPS_POSSIBLE_BREAKPOINT();
  _f.tokv = tksrc->lookahead_token(&_, 0);
  RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum << " from "
                << __FILE__ << ":" << lin
                << " tksrc=" << *tksrc
                << " tokv=" << _f.tokv);
  RPS_POSSIBLE_BREAKPOINT();
  if (!_f.tokv) {
    RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum << " from "
                  << __FILE__ << ":" << lin
                  << " tksrc=" << *tksrc
                  << " got end of file from " << std::endl
                  << RPS_FULL_BACKTRACE(1, "rps_carbrepl_next_token"));
    return RPSCARBREPL_EOF;     // should that be
                                // _RPSCARBREPL_END_OF_INPUT?
  };
  //////
  _f.kindtokob = _f.tokv.as_lextoken()->lxkind();
  _f.valtokv = _f.tokv.as_lextoken()->lxval();
  RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                << " from "
                << __FILE__ << ":" << lin
                << " tksrc=" << *tksrc
                << std::endl  << "… tokv=" << _f.tokv
                << " of °kindtokob=" << _f.kindtokob
                << " and valtokv=" << _f.valtokv
                << std::endl 
                << " from "
                << __FILE__ << ":" << lin);
  RPS_POSSIBLE_BREAKPOINT();
  if (_f.kindtokob == RPS_ROOT_OB(_2A2mrPpR3Qf03p6o5b)) //int∈class
    {
      RPS_POSSIBLE_BREAKPOINT();
      RPS_ASSERT(_f.valtokv.is_int());
      RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                    << " gives INT " << _f.valtokv);
      _Pragma("message \"rps_carbrepl_next_token should transmit value of INT\"");
      return RPSCARBREPL_INT;
    }
  else if (_f.kindtokob == RPS_ROOT_OB(_2wdmxJecnFZ02VGGFK) //repl_delimiter∈class
          ) {
    RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                  << "°delim kindtokob=" << _f.kindtokob
                  << " valtokv=" << _f.valtokv);
    if (_f.valtokv.is_object()) {
      _f.valtokob = _f.valtokv.as_object();
      RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                    << "°delim kindtokob=" << _f.kindtokob
                    << std::endl
                    << " valtokob=" << RPS_OBJECT_DISPLAY(_f.valtokob));
      _f.carbtermv =
        _f.valtokob->get_physical_attr
        (rpskob_1cUbHIFNNXi00HOCWM); //!carburetta_terminal∈named_attribute
      RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                    << " valtokob=" << _f.valtokob
                    << " wirth carbtermv=" << _f.carbtermv);
      if (_f.carbtermv.is_int()) {
        int carbrank = _f.carbtermv.as_int();
        char carbtermbuf[16];
        memset(carbtermbuf, 0, sizeof(carbtermbuf));
        const char *termname = nullptr;
        if (carbrank>0 && carbrank<rpscarbrepl_symbol_names_length_)
          termname=rpscarbrepl_symbol_names_[carbrank];
        if (!termname) {
          snprintf(carbtermbuf, sizeof(carbtermbuf)-1, "#?Carb-%d", carbrank);
          termname = carbtermbuf;
        };        
        RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                      << " gives " << _f.carbtermv
                      << " which is " << termname << std::endl
                      << RPS_FULL_BACKTRACE(1, "rps_carbrepl_next_token/terminal"));
        return carbrank;
      }
    }
    RPS_POSSIBLE_BREAKPOINT();
  }
  RPS_POSSIBLE_BREAKPOINT(); /// GDB could set gdb_do_return & gdb_returned
  RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                << " kindtokob=" << _f.kindtokob
                << " valtokv=" << _f.valtokv
                << " tokv=" << _f.tokv
                << " °gdb_do_return at "
                << (void*)&gdb_do_return << " is "
                << (gdb_do_return?"SET":"CLEARED")
                << " gdb_returned at " << (void*)&gdb_returned
                << " is " << gdb_returned);
  RPS_POSSIBLE_BREAKPOINT(); /// GDB could set gdb_do_return & gdb_returned
  //// temporary trick to help debugging with GDB
  asm volatile (".global carbrepl_rps_issue; nop; carbrepl_rps_issue: nop; nop; nop");
  RPS_ASSERT(&gdb_do_return != nullptr);
  RPS_POSSIBLE_BREAKPOINT(); /// GDB could set gdb_do_return & gdb_returned
  //// for GDB
  if (gdb_do_return) {
    RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                  << "- tksrc=" << *tksrc << " tokv=" << _f.tokv
                  << " gdb_returned=" << gdb_returned);
    RPS_INFORMOUT("rps_carbrepl_next_token from#" << callnum
                  << "- lin=" << lin << " tokv=" << _f.tokv
                  << " GDB returning " << gdb_returned);
    return gdb_returned;
  }
  else {
    RPS_POSSIBLE_BREAKPOINT();
    RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token#" << callnum
                  << "- tksrc=" << *tksrc << std::endl
                  << "… tokv=" << _f.tokv
                  << " kindtokob=" << _f.kindtokob
                  << " valtokv=" << _f.valtokv
                  << "… no°gdb_do_return" << std::endl
                  << RPS_FULL_BACKTRACE(1, "rps_carbrepl_next_token-gdb"));
  };
  ////
  RPS_POSSIBLE_BREAKPOINT();
#warning unimplemented rps_carbrepl_next_token
  RPS_FATALOUT("unimplemented rps_carbrepl_next_token#" << callnum
               << " from "
               << __FILE__ << ":" << lin
               << std::endl << "… tksrc=" << *tksrc
               << "… tokv=" << _f.tokv
               << " kindtokob=" << _f.kindtokob
               << " valtokv=" << _f.valtokv
               << std::endl
               << Rps_Do_Output([&](std::ostream& out)
               {
                 tksrc->display_current_line_with_cursor(out);
               })
               << std::endl);
} // end rps_carbrepl_next_token




void
rps_do_carburetta_tokensrc(Rps_CallFrame*callerframe, Rps_ObjectRef obenvarg,
                                Rps_TokenSource*tksrc)
{
  RPS_LOCALFRAME(/*descr:*/RPS_ROOT_OB(_4CZZ2JlnkQT02YJ6sM), //replnt_command∈symbol
                 callerframe,
                 Rps_ObjectRef obenv;
                );
  _Pragma("message \"rps_do_carburetta_tokensrc\"");
  RPS_ASSERT(tksrc);
  _f.obenv = obenvarg;
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_tokensrc starting obenv="
                << RPS_OBJECT_DISPLAY(_f.obenv) << std::endl
                << "…  tksrc=" << *tksrc << "@" << (void*)tksrc
                << " FROM thread " << rps_current_pthread_name()
                << RPS_FULL_BACKTRACE(1, "start rps_do_carburetta_tokensrc")
                << std::endl);
  RPS_POSSIBLE_BREAKPOINT();
  struct rpscarbrepl_stack carbstack;
  struct rps_carbrepl_data_st carbdata;
  memset ((void*)&carbstack, 0, sizeof(carbstack));
  memset ((void*)&carbdata, 0, sizeof(carbdata));
  carbdata.cardata_magic = rps_magic_carbrepl_data;
  rpscarbrepl_stack_init(&carbstack);
  _.set_additional_gc_marker([&](Rps_GarbageCollector*gc) {
    RPS_ASSERT(gc != nullptr);
    rpscarbrepl_stack_visit(&carbstack, gc, &carbdata);
    gc->mark_obj(carbdata.cardata_ob1);
    gc->mark_obj(carbdata.cardata_ob2);
    gc->mark_obj(carbdata.cardata_obdelim);
    gc->mark_obj(carbdata.cardata_obop);
    gc->mark_value(carbdata.cardata_v1);
    gc->mark_value(carbdata.cardata_v2);
    gc->mark_value(carbdata.cardata_vleft);
    gc->mark_value(carbdata.cardata_vright);
    gc->mark_value(carbdata.cardata_vinst);
    });
  RPS_ASSERT(callerframe && callerframe->is_good_call_frame());
  RPS_POSSIBLE_BREAKPOINT();
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_tokensrc obenv=" << _f.obenv
                << " tksrc=" << *tksrc);
  RPS_POSSIBLE_BREAKPOINT();
#warning check this
  int r = rpscarbrepl_parse(&carbstack, /*sym:*/RPSCARBREPL_REPLNT_INPUT, tksrc, &_, carbdata);
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_tokensrc after rpscarbrepl_parse r=" << r
                << ":" <<  RPS_CARBREPL_SYMBOL_NAME(r)
                << " obenv=" << RPS_OBJECT_DISPLAY(_f.obenv) << std::endl
                << " tksrc=" << *tksrc << std::endl
		<< " carbdata: {v1=" << carbdata.cardata_v1
		<< ", v2=" <<  carbdata.cardata_v2
		<< ", ob1=" << carbdata.cardata_ob1
		<< ", ob2=" << carbdata.cardata_ob2
		<< "}" 
                << std::endl
                << RPS_FULL_BACKTRACE(1, "rps_do_carburetta_tokensrc°+pars"));
  RPS_POSSIBLE_BREAKPOINT();
  RPS_WARNOUT("rps_do_carburetta_tokensrc perhaps unimplemented"
                << std::endl
                << RPS_FULL_BACKTRACE(1, "rps_do_carburetta_tokensrc°+pars"));
#warning unimplemented rps_do_carburetta_tokensrc
  /// TODO: should probably use generated scanning routines
  /// the last statement should be the following cleanup
  rpscarbrepl_stack_cleanup(&carbstack);
  RPS_POSSIBLE_BREAKPOINT();
} // end rps_do_carburetta_tokensrc



void
rps_do_carburetta_command(Rps_CallFrame*callerframe, Rps_ObjectRef obenvarg, Rps_TokenSource*ptoksrc)
{
  RPS_LOCALFRAME(/*descr:*/RPS_ROOT_OB(_4CZZ2JlnkQT02YJ6sM), //replnt_command∈symbol
                 callerframe,
                 Rps_ObjectRef obenv;
                );
  _Pragma("message \"rps_do_carburetta_command\"");
  _f.obenv = obenvarg;
  RPS_ASSERT(callerframe && callerframe->is_good_call_frame());
  RPS_ASSERT(ptoksrc != nullptr);
  RPS_POSSIBLE_BREAKPOINT();
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_command start *ptoksrc=" << *ptoksrc
                << std::endl
                << "… obenv=" << RPS_OBJECT_DISPLAY(_f.obenv) << std::endl
                << RPS_FULL_BACKTRACE(1, "rps_do_carburetta_command start")
                << std::endl
                << "… "
                << std::endl
                << "… °%° __GNUC__=" << __GNUC__
                << " __VERSION__=" << __VERSION__
                << " __TIMESTAMP__=" << __TIMESTAMP__
                << std::endl
                << "… "
                << " __FUNCTION__=" << __FUNCTION__
                << " __func__=" << __func__
                << " __PRETTY_FUNCTION__=" << __PRETTY_FUNCTION__);
  bool gotlin = ptoksrc->get_line();
  RPS_POSSIBLE_BREAKPOINT();
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_command before rps_do_carburetta_tokensrc *ptoksrc="
                << *ptoksrc << " " << (gotlin?"got line":"NO line"));
  RPS_POSSIBLE_BREAKPOINT();
  rps_do_carburetta_tokensrc(&_, _f.obenv, ptoksrc);
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_command end *ptoksrc=" << *ptoksrc
                << std::endl
                << "… obenv=" << _f.obenv << std::endl
                << RPS_FULL_BACKTRACE(1, "rps_do_carburetta_command end"));
}  // end rps_do_carburetta_command



 void
 rps_carbrepl_do_display_command(Rps_CallFrame*callerframe, Rps_ObjectRef obenvarg, Rps_Value exprarg)
 {
   RPS_LOCALFRAME(RPS_ROOT_OB(_006mAbXTG4G00QR5HS), ///display∈symbol h:2127571271
                  callerframe,
                  Rps_ObjectRef obenv;
                  Rps_Value exprv;
                 );
   _f.obenv = obenvarg;
   _f.exprv = exprarg;
  RPS_ASSERT(callerframe && callerframe->is_good_call_frame());
  RPS_DEBUG_LOG(REPL, "rps_carbrepl_do_display_command starting obenv="
                << RPS_OBJECT_DISPLAY(_f.obenv) << std::endl
                << " expr=" << _f.exprv
                << std::endl
                << RPS_FULL_BACKTRACE(1, "carburetta command display"));
  RPS_POSSIBLE_BREAKPOINT();
  RPS_DEBUG_LOG(CMD, "carburetta display obenv=" << RPS_OBJECT_DISPLAY(_f.obenv) << std::endl
                << "display expr=" << _f.exprv
                << std::endl
                << RPS_FULL_BACKTRACE(1, "carburetta command display"));
  RPS_POSSIBLE_BREAKPOINT();
#warning incomplete rps_do_display_carburetta_command
  // TODO: should evaluate exprv in obenv and display it
  RPS_WARNOUT("incomplete rps_carbrepl_do_display_command obenv=" << _f.obenv << " exprv=" << _f.exprv);
 } // end rps_carbrepl_do_display_command


static void
rps_carburetta_fill_delimiter(Rps_ObjectRef obdelim, int num, int line)
{
  RPS_ASSERT(obdelim);
  RPS_ASSERT(line > __LINE__);
  Rps_ObjectRef obcarbterm = rpskob_1cUbHIFNNXi00HOCWM /*carburetta_terminal*/;
  Rps_Value atv = obdelim->get_physical_attr(obcarbterm/*carburetta_terminal*/);
  RPS_ASSERT(num>0 && num<rpscarbrepl_symbol_names_length_
            && rpscarbrepl_symbol_names_[num] != nullptr);
  if (atv != Rps_Value::make_tagged_int(num)) {
    obdelim->put_attr(obcarbterm,
                      Rps_Value::make_tagged_int(num));
    RPS_DEBUG_LOG(REPL, "rps_carburetta_fill_delimiter filled from "
                  << __FILE__ << ":" << line
                  << " delimiter#" <<num << ":" << rpscarbrepl_symbol_names_[num] << std::endl
                  << RPS_OBJECT_DISPLAY(obdelim));
  }
  else
    RPS_DEBUG_LOG(REPL, "rps_carburetta_fill_delimiter good delimiter "
                  << obdelim
                  << " delimiter#" <<num << ":" << rpscarbrepl_symbol_names_[num]
                  << " from " << __FILE__ << ":" << line);
} // end rps_carburetta_fill_delimiter

static void
rps_carburetta_fill_keyword(Rps_ObjectRef obkeyw, int num, int line)
{
  RPS_ASSERT(obkeyw);
  RPS_ASSERT(line > __LINE__);
  RPS_ASSERT(num>0 && num<rpscarbrepl_symbol_names_length_
             && rpscarbrepl_symbol_names_[num] != nullptr
             && strncmp(rpscarbrepl_symbol_names_[num], "KEYW_", sizeof("KEYW_")-1)==0);
  Rps_ObjectRef obcarbkeyw = rpskob_083n2ydb4Zm03bbZW1/*carburetta_keyword*/;
  Rps_Value atv = obkeyw->get_physical_attr(obcarbkeyw);
  if (atv != Rps_Value::make_tagged_int(num)) {
    obkeyw->put_attr(obcarbkeyw,
                      Rps_Value::make_tagged_int(num));
    RPS_DEBUG_LOG(REPL, "rps_carburetta_fill_delimiter filled from "
                  << __FILE__ << ":" << line
                  << " keyword#" <<num << ":" << rpscarbrepl_symbol_names_[num] << std::endl
                  << RPS_OBJECT_DISPLAY(obkeyw));
  }
  else
    RPS_DEBUG_LOG(REPL, "rps_carburetta_fill_delimiter good keyword "
                  << obkeyw
                  << " delimiter#" <<num << ":" << rpscarbrepl_symbol_names_[num]
                  << " from " << __FILE__ << ":" << line);
} // end rps_carburetta_fill_keyword


void
rps_initialize_carburetta_after_load(Rps_Loader*ld)
{
  RPS_ASSERT(ld);
  ///////////////////////////////////
  ///// fill the delimiters constants
#define RPS_CARBURETTA_DELIM(Ob,Num) \
  rps_carburetta_fill_delimiter((Ob),(Num),__LINE__)
  RPS_CARBURETTA_DELIM
    (rpskob_7LMYzEqjeDH00ZI1CO,//$at_sign∈repl_delimiter h:150658742
     RPSCARBREPL_ATSIGN);
  RPS_CARBURETTA_DELIM
  (rpskob_4YM7mv0GrSp03OkF8T, //!leftparen!delim∈repl_delimiter
   RPSCARBREPL_LEFTPAREN);
  RPS_CARBURETTA_DELIM
    (rpskob_7CG9m1NXpMo01edTUl, //!rightparen!delim∈repl_delimiter
     RPSCARBREPL_RIGHTPAREN);
  RPS_CARBURETTA_DELIM
    (rpskob_78wsBiJhJj1025DIs1, //!!dot!delim∈repl_delimiter 
     RPSCARBREPL_DOT);
  RPS_CARBURETTA_DELIM
    (rpskob_4YM7mv0GrSp03OkF8T, //!!leftparen!delim∈repl_delimiter
     RPSCARBREPL_LEFTPAREN);
  RPS_CARBURETTA_DELIM
    (rpskob_7CG9m1NXpMo01edTUl, //!!rightparen!delim∈repl_delimiter
     RPSCARBREPL_RIGHTPAREN);
  RPS_CARBURETTA_DELIM
    (rpskob_6kHcxtGAtWW03dZ14O, //!!$leftbrace!delim∈repl_delimiter 
     RPSCARBREPL_LEFTBRACE);
  RPS_CARBURETTA_DELIM
    (rpskob_68wsAiJhJj1025DIs1, //!!$rightbrace!delim∈repl_delimiter 
     RPSCARBREPL_RIGHTBRACE);
#undef RPS_CARBURETTA_DELIM
  /////
  ///////////////////////////////////
  ///// fill the keywords constants
#define RPS_CARBURETTA_KEYWORD(Ob,Num) \
  rps_carburetta_fill_keyword((Ob),(Num),__LINE__)
  /// keyword `display`
  RPS_CARBURETTA_KEYWORD(RPS_ROOT_OB(_006mAbXTG4G00QR5HS), RPSCARBREPL_KEYW_DISPLAY); //display∈symbol
  /// keyword `object`
  RPS_CARBURETTA_KEYWORD(rpskob_7X9eGs8601M021nMue, RPSCARBREPL_KEYW_OBJECT); //$object∈symbol
  /// keyword `put`
  RPS_CARBURETTA_KEYWORD(rpskob_7oLVM0fd4a5020iEEM, RPSCARBREPL_KEYW_PUT); //$put∈symbol
  /// 
#undef RPS_CARBURETTA_KEYWORD
  ///////////////////////////////////
  RPS_DEBUG_LOG(REPL, "initialize°carburetta done");
#warning incomplete rps_initialize_carburetta_after_load
  RPS_WARNOUT("incomplete rps_initialize_carburetta_after_load"
              << std::endl
              << RPS_FULL_BACKTRACE(1, "rps_initialize_carburetta_after_load"));
} // end rps_initialize_carburetta_after_load


const char*
rps_carbrepl_symname_at(int symnum, int lin) {
//// https://github.com/kingletbv/carburetta/issues/9
  RPS_POSSIBLE_BREAKPOINT();
  if (symnum>0 && symnum<rpscarbrepl_symbol_names_length_
      && rpscarbrepl_symbol_names_[symnum]) {
    RPS_DEBUG_LOG(REPL, "°carbrepl_symname symnum#" << symnum
                  << " lin:" << lin
                  << " is "
                  << rpscarbrepl_symbol_names_[symnum]);
    return rpscarbrepl_symbol_names_[symnum];
  }
  else {
    RPS_WARNOUT("°carbrepl_symname bad symnum#" << symnum
                  << " lin:" << lin
                << RPS_FULL_BACKTRACE(1, "carbrepl_symname/BAD"));
    RPS_POSSIBLE_BREAKPOINT();
    static char buf[32];
    memset (buf, 0, sizeof(buf));
    snprintf(buf, sizeof(buf), "*BADSYM%d@%d*", symnum, lin);
    return buf;
  }
} // end rps_carbrepl_symname_at

////////////////////////////////////////////////////////////////

int
rps_carbrepl_keyword_lexer (Rps_CallFrame*callerframe,
			    const std::string&keystr,
			    Rps_ObjectRef obkwarg)
{
  RPS_ASSERT(callerframe && callerframe->is_good_call_frame());
  RPS_LOCALFRAME(RPS_CALL_FRAME_UNDESCRIBED,
	/*prev:*/callerframe,
		 Rps_ObjectRef obkeyw;
		 Rps_Value cval;
		);
  _f.obkeyw = obkwarg;
  RPS_ASSERT(_f.obkeyw);
  std::lock_guard<std::recursive_mutex> gu(*_f.obkeyw->objmtxptr());
  int numkeyw = -1;
  _f.cval = _f.obkeyw->get_physical_attr(rpskob_083n2ydb4Zm03bbZW1); //!carburetta_keyword∈named_attribute
  if (_f.cval.is_int()) {
    numkeyw = _f.cval.as_int();
    const char*keywname = RPS_CARBREPL_SYMBOL_NAME(numkeyw);
    RPS_DEBUG_LOG(REPL, "rps_carbrepl_keyword_lexer keystr=" << keystr
		  << " obkeyw=" << RPS_OBJECT_DISPLAY(_f.obkeyw)
		  <<  " cval=" << _f.cval << ":" <<  keywname);
    if (keywname && !strncmp(keywname, "KEYW_", sizeof("KEYW_")-1)) {
      RPS_DEBUG_LOG(REPL, "rps_carbrepl_keyword_lexer got keyword#" << numkeyw
		    << " keystr=" << keystr
		    << " obkeyw=" << RPS_OBJECT_DISPLAY(_f.obkeyw)
		    <<  " cval=" << _f.cval << ":" <<  keywname
		    << RPS_FULL_BACKTRACE(1, "rps_carbrepl_keyword_lexer"));
    return numkeyw;
    }
  };
  RPS_FATALOUT("corrupted rps_carbrepl_keyword_lexer keystr="
               << keystr
               << " obkeyw=" << RPS_OBJECT_DISPLAY(_f.obkeyw)
	       << " cval=" << _f.cval << ":" <<  RPS_CARBREPL_SYMBOL_NAME(numkeyw));
  return -1;
} // end rps_carbrepl_keyword_lexer

extern "C" const size_t rpscarbrepl_stack_size;
extern "C" const size_t rpscarbrepl_stack_align;

const size_t rpscarbrepl_stack_size = sizeof(struct rpscarbrepl_stack);
const size_t rpscarbrepl_stack_align = alignof(struct rpscarbrepl_stack);
/****************
 **                           for Emacs...
 ** Local Variables: ;;
 ** mode: c++ ;;
 ** compile-command: "make _carbrepl_rps.o && make" ;;
 ** End: ;;
 ****************/
