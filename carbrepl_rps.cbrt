/****************************************************************
 * file carbrepl_rps.cbrt
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 * Description:
 *      This file is part of the Reflective Persistent System.
 *      It is almost its Carburetta grammar
 *      see https://carburetta.com/
 *
 * Author(s):
 *      Basile Starynkevitch, France   <basile@starynkevitch.net>
 *
 *      © Copyright 2025 The Reflective Persistent System Team
 *      team@refpersys.org & http://refpersys.org/
 *
 * License: GPLv3+ (file COPYING-GPLv3)
 *    This software is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version. NO WARRANTY
 ****************************************************************/

#include "refpersys.hh"
#pragma message "prologue part of carbrepl_rps.cbrt"

#ifndef RPS_GITID
#error RPS_GITID is not defined by compilation command
#endif

extern "C" void rps_carbrepl_do_display_command(Rps_CallFrame*callframe, Rps_ObjectRef obenv, Rps_Value expr);
static void rps_carbrepl_constructor_replnt_object(Rps_ObjectRef&obr, int lin);
static void rps_carbrepl_destructor_replnt_object(Rps_ObjectRef&obr, int lin);


static void rps_carbrepl_constructor_replnt_atom(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_atom(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_expr(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_expr(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_factor(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_factor(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_term(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_term(Rps_Value&val, int lin);

static void rps_carbrepl_constructor_replnt_value(Rps_Value&val, int lin);
static void rps_carbrepl_destructor_replnt_value(Rps_Value&val, int lin);

extern "C" int rps_carbrepl_next_token(Rps_CallFrame*callframe, Rps_TokenSource*tksrc, int lin);
int rps_carbrepl_next_token(Rps_CallFrame*callframe, Rps_TokenSource*tksrc, int lin);

extern "C" struct rpscarbrepl_stack;

/// The following is related to the the visitor facility in carburetta 0.8.25 or newer (april 2025)
/// See https://github.com/kingletbv/carburetta/issues/4
extern "C" void rps_carbrepl_garbage_collect_visit_stack(struct rpscarbrepl_stack*,Rps_GarbageCollector*);
%visit_params Rps_GarbageCollector*visitgc


%header%
#pragma message "header part of carbrepl_rps.cbrt"
extern "C" const char rps_carbrepl_gitid[];
extern "C" const char rps_carbrepl_date[];
extern "C" const char rps_carbrepl_shortgitid[];
%%

%prefix rpscarbrepl_
//forbidden %token_action here since it must follow %token_type, %type, %class, %common_type or %common_class directive
%end_token EOF

%token ATSIGN
 //ATSIGN being untyped cannot have a token_action

%token INT
%type INT: intptr_t
%token_action {  _Pragma("message \"token_action for INT\""); \
  /* should assign $$ for INT */ \
  RPS_FATALOUT("INT token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action INT"));	\
 }

%token DOUBLE
%type DOUBLE: double
%token_action {  _Pragma("message \"token_action for DOUBLE\""); \
  /* should assign $$ for DOUBLE */ \
  RPS_FATALOUT("DOUBLE token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action DOUBLE"));	\
 }

%token STRING
%type STRING: std::string
%token_action { _Pragma("message \"token_action for STRING\""); \
  /* should assign $$ for STRING */ \
  RPS_FATALOUT("STRING token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action STRING"));	\
 }

%token NAME
%type NAME: std::string
%token_action {  _Pragma("message \"token_action for NAME\"");  \
  /* should assign $$ for NAME */ \
  RPS_FATALOUT("NAME token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action NAME"));	\
 }

%token OID
%type OID: Rps_Id
%token_action { _Pragma("message \"token_action for OID\"");   \
  /* should assign $$ for OID */ \
  RPS_FATALOUT("OID token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action NAME"));	\
 }

%token KEYW_DISPLAY
%token_action { _Pragma("message \"token_action for KEYW_DISPLAY\"");  \
  /* should assign $$ for KEYW_DISPLAY */ \
  RPS_FATALOUT("KEYW_DISPLAY token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action KEYW_DISPLAY"));	\
 }

%token KEYW_OBJECT
%token_action { _Pragma("message \"token_action for KEYW_OBJECT\""); \
  /* should assign $$ for KEYW_OBJECT */ \
  RPS_FATALOUT("KEYW_OBJECT token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action KEYW_OBJECT"));	\
 }

%token KEYW_PUT
%token_action { _Pragma("message \"token_action for KEYW_PUT\"");  \
  /* should assign $$ for KEYW_PUT */ \
  RPS_FATALOUT("KEYW_OBJECT token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action KEYW_OBJECT"));	\
 }
 

%token DOT
%token_action { _Pragma("message \"token_action for DOT\""); \
  /* should assign $$ for DOT */ \
  RPS_FATALOUT("DOT token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action DOT"));	\
 }

%token ASSIGN
%token_action {_Pragma("message \"token_action for ASSIGN\""); \
  /* should assign $$ for ASSIGN */ \
  RPS_FATALOUT("ASSIGN token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action ASSIGN"));	\
 }

%token LEFTPAREN
%token_action {_Pragma("message \"token_action for LEFTPAREN\""); \
  /* should assign $$ for LEFTPAREN */ \
  RPS_FATALOUT("LEFTPAREN token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action LEFTPAREN"));	\
 }

%token RIGHTPAREN
%token_action {_Pragma("message \"token_action for RIGHTPAREN\""); \
  /* should assign $$ for RIGHTPAREN */ \
  RPS_FATALOUT("RIGHTPAREN token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action RIGHTPAREN"));	\
 }
//

%token PLUS 
%token_action {_Pragma("message \"token_action for PLUS\""); \
  /* should assign $$ PLUS */ \
  RPS_FATALOUT("PLUS token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action PLUS"));	\
 }
//

%token MINUS 
%token_action {_Pragma("message \"token_action for MINUS\""); \
  /* should assign $$ MINUS */ \
  RPS_FATALOUT("MINUS token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action MINUS"));	\
 }
//


%token ASTERISK 
%token_action {_Pragma("message \"token_action for ASTERISK\""); \
  /* should assign $$ ASTERISK */ \
  RPS_FATALOUT("ASTERISK token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action ASTERISK"));	\
 }
//

%token SLASH 
%token_action {_Pragma("message \"token_action for SLASH\""); \
  /* should assign $$ SLASH */ \
  RPS_FATALOUT("SLASH token_action is incomplete tksrc=" << tksrc << " sym=" << sym \
	       << RPS_FULL_BACKTRACE_HERE(1, "token_action SLASH"));	\
 }
//

%grammar%
%params Rps_TokenSource* tksrc, Rps_CallFrame* callframe
%nt replnt_input replnt_command
%nt replnt_atom replnt_object replnt_expr replnt_term replnt_factor replnt_value



// When the parser (not the scanner) needs a new input terminal symbol, the specified action code snippet is executed.
// we probably need to use Rps_TokenSource::lookahead_token
%on_next_token {_Pragma("message \"on_next_token code\""); \
    RPS_POSSIBLE_BREAKPOINT(); \
    RPS_DEBUG_LOG(REPL, "on_next_token start tksrc=" << *tksrc); \
    int ntk = rps_carbrepl_next_token(callframe, tksrc, __LINE__); \
    RPS_DEBUG_LOG(REPL, "on_next_token tksrc=" << *tksrc << " is " << ntk); \
    return ntk; }



%type replnt_object: Rps_ObjectRef
%constructor rps_carbrepl_constructor_replnt_object($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_object($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_object\"");RPS_ASSERT(visitgc);$$->gc_mark(*visitgc);}

%type replnt_atom: Rps_Value
%constructor rps_carbrepl_constructor_replnt_atom($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_atom($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_atom\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}


%type replnt_expr: Rps_Value
%constructor rps_carbrepl_constructor_replnt_expr($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_expr($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_expr\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}



%type replnt_term: Rps_Value
%constructor rps_carbrepl_constructor_replnt_term($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_term($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_term\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}



%type replnt_factor: Rps_Value
%constructor rps_carbrepl_constructor_replnt_factor($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_factor($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_factor\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}


%type replnt_value: Rps_Value
%constructor rps_carbrepl_constructor_replnt_value($$,__LINE__);
%destructor rps_carbrepl_destructor_replnt_value($$,__LINE__);
%visit {_Pragma("message \"visit code for replnt_value\"");RPS_ASSERT(visitgc);$$.gc_mark(*visitgc);}


%type replnt_input: int
%type replnt_command: int


/* the start symbol is the first non-terminal */
replnt_input: EOF {
  _Pragma("message \"replnt_input as EOF in carbrepl_rps.cbrt\"");
  RPS_ASSERT("empty replnt_input" && tksrc != nullptr);
  RPS_ASSERT(callframe != nullptr && callframe->is_good_call_frame());
  $$ = 0;
}

replnt_input: replnt_command replnt_input {
   _Pragma("message \"replnt_input as replnt_command replnt_input in carbrepl_rps.cbrt\"");
   RPS_ASSERT("command replnt_input" && tksrc != nullptr);
   RPS_ASSERT(callframe != nullptr && callframe->is_good_call_frame());
   $$ = $1 + 1;
}

replnt_command: ATSIGN KEYW_DISPLAY replnt_expr {
   _Pragma("message \"replnt_command as KEYW_DISPLAY replnt_expr in carbrepl_rps.cbrt\"");
   RPS_DEBUG_LOG(REPL, "show carburetta command:" << $2);
   RPS_ASSERT(callframe != nullptr && callframe->is_good_call_frame());
   RPS_POSSIBLE_BREAKPOINT();
   rps_carbrepl_do_display_command(callframe, rps_get_first_repl_environment(), $2);
   RPS_POSSIBLE_BREAKPOINT();
   $$ = 1;
}

replnt_command: ATSIGN KEYW_PUT replnt_object DOT replnt_object ASSIGN replnt_expr {
   _Pragma("message \"replnt_command as KEYW_PUT replnt_object DOT replnt_object ASSIGN replnt_expr in carbrepl_rps.cbrt\"");
   RPS_DEBUG_LOG(REPL, "put carburetta command:" << $2 << " attr " << $4 << " expr " << $6);
   RPS_POSSIBLE_BREAKPOINT();
   RPS_ASSERT(callframe != nullptr && callframe->is_good_call_frame());
}

replnt_command: error {
  RPS_POSSIBLE_BREAKPOINT();
  RPS_WARNOUT("invalid syntax for command");
}

replnt_atom: INT {
_Pragma("message \"replnt_atom as INT in carbrepl_rps.cbrt\"");
 RPS_POSSIBLE_BREAKPOINT();
  $$ = Rps_Value::make_tagged_int($0);
  RPS_DEBUG_LOG(REPL, "atom is INT " << $$);
}

replnt_atom: DOUBLE {
_Pragma("message \"replnt_atom as DOUBLE in carbrepl_rps.cbrt\"");
  $$ = Rps_DoubleValue($0);
  RPS_DEBUG_LOG(REPL, "atom is DOUBLE " << $$);
}

replnt_atom: STRING {
_Pragma("message \"replnt_atom as STRING in carbrepl_rps.cbrt\"");
  $$ = Rps_StringValue($0);
  RPS_DEBUG_LOG(REPL, "atom is STRING " << $$);
}

replnt_atom: replnt_object {
  _Pragma("message \"replnt_atom as replnt_object in carbrepl_rps.cbrt\"");
  $$ = Rps_ObjectValue($0);
  RPS_DEBUG_LOG(REPL, "atom is object " << $$);
}

replnt_object: NAME {
  _Pragma("message \"replnt_object as NAME in carbrepl_rps.cbrt\"");
  $$ = Rps_PayloadSymbol::find_named_object($0);
  RPS_DEBUG_LOG(REPL, "object is name " << $$);
}

replnt_object: OID {
  _Pragma("message \"replnt_object as OID in carbrepl_rps.cbrt\"");
  $$ = Rps_ObjectRef::really_find_object_by_oid($0);
  RPS_DEBUG_LOG(REPL, "object is oid " << $$);
}


replnt_expr: KEYW_OBJECT replnt_object {
  _Pragma("message \"replnt_expr as KEYW_OBJECT replnt_object in carbrepl_rps.cbrt\"");
  $$ = Rps_ObjectValue($1);
  RPS_DEBUG_LOG(REPL, "expr is object " << $$);
}


replnt_expr: replnt_term                      {
  _Pragma("message \"replnt_expr as replnt_term in carbrepl_rps.cbrt\"");
  RPS_DEBUG_LOG(REPL, "expr is term " << $$);
  $$ = $0;
}

replnt_expr: replnt_expr PLUS replnt_term            {            
  _Pragma("message \"replnt_expr as replnt_expr PLUS replnt_term in carbrepl_rps.cbrt\"");
  // $$ = $0 + $2;
}

replnt_expr: replnt_expr MINUS replnt_term           {
  _Pragma("message \"replnt_expr as replnt_expr MINUS replnt_term in carbrepl_rps.cbrt\"");
  // $$ = $0 - $2;
}
  
replnt_term: replnt_factor                    {
  _Pragma("message \"replnt_term as replnt_factor in carbrepl_rps.cbrt\"");
  $$ = $0;
}

replnt_term: replnt_term ASTERISK replnt_factor      {
  _Pragma("message \"replnt_term as replnt_term ASTERISK replnt_factor in carbrepl_rps.cbrt\"");
  //  $$ = $0 * $2;
  }

replnt_term: replnt_term SLASH replnt_factor         {
  _Pragma("message \"replnt_term as replnt_term SLASH replnt_factor in carbrepl_rps.cbrt\"");
  //  $$ = $0 / $2;
  }
  
replnt_factor: replnt_atom                   {
  _Pragma("message \"replnt_factor as replnt_atom in carbrepl_rps.cbrt\"");
  // $$ = $0;
  }
replnt_factor: MINUS replnt_factor            {
  _Pragma("message \"replnt_factor as MINUS replnt_factor in carbrepl_rps.cbrt\"");
  // $$ = -$1;
  }

replnt_factor: LEFTPAREN replnt_expr RIGHTPAREN {
  _Pragma("message \"replnt_factor as LEFTPAREN replnt_factor RIGHTPAREN in carbrepl_rps.cbrt\"");
  // $$ = $1;
  }

 
%%


#pragma message "trailer of carbrepl_rps.cbrt"

//// for objects in REPL
void
rps_carbrepl_constructor_replnt_object(Rps_ObjectRef&obr, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  _Pragma("message \"rps_carbrepl_constructor_replnt_object\"");
  obr = nullptr;
} // end rps_carbrepl_constructor_replnt_object

void
rps_carbrepl_destructor_replnt_object(Rps_ObjectRef&obr, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  _Pragma("message \"rps_carbrepl_replnt_object_destructor\"");
  obr = nullptr;
} // end rps_carbrepl_replnt_object_destructor



//// for atoms in REPL
void
rps_carbrepl_constructor_replnt_atom(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_atom\"");
} // end rps_carbrepl_constructor_replnt_atom

void
rps_carbrepl_destructor_replnt_atom(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_atom\"");
} // end rps_carbrepl_replnt_object_destructor_replnt_atom



//// for expressions in REPL
void
rps_carbrepl_constructor_replnt_expr(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_expr\"");
} // end rps_carbrepl_constructor_replnt_expr

void
rps_carbrepl_destructor_replnt_expr(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_expr\"");
} // end rps_carbrepl_replnt_destructor_replnt_expr

void
rps_carbrepl_constructor_replnt_term(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_term\"");
} // end rps_carbrepl_constructor_replnt_term

void
rps_carbrepl_destructor_replnt_term(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_term\"");
} // end rps_carbrepl_replnt_destructor_replnt_term

void
rps_carbrepl_constructor_replnt_factor(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_factor\"");
} // end rps_carbrepl_constructor_replnt_factor

void
rps_carbrepl_destructor_replnt_factor(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_factor\"");
} // end rps_carbrepl_replnt_destructor_replnt_factor

void
rps_carbrepl_constructor_replnt_value(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_constructor_replnt_value\"");
} // end rps_carbrepl_constructor_replnt_factor

void
rps_carbrepl_destructor_replnt_value(Rps_Value&val, int lin)
{
  RPS_ASSERT(lin>0);
  RPS_POSSIBLE_BREAKPOINT();
  val = nullptr;
  _Pragma("message \"rps_carbrepl_destructor_replnt_value\"");
} // end rps_carbrepl_replnt_destructor_replnt_value

int
rps_carbrepl_next_token(Rps_CallFrame*callframe, Rps_TokenSource*tksrc, int lin)
{
  /// used by %on_next_token above
  bool gdb_do_return=false; // to be set from GDB
  int gdb_returned= 0;      // to be set from GDB
  RPS_POSSIBLE_BREAKPOINT();
  RPS_LOCALFRAME(/*descr:*/RPS_ROOT_OB(_4CZZ2JlnkQT02YJ6sM), //replnt_command∈symbol
                 callframe,
                 Rps_ObjectRef obenv;
		 Rps_Value tokv;
		 Rps_Value nextokv;
                );
  RPS_ASSERT(tksrc);
  RPS_ASSERT(callframe && callframe->is_good_call_frame());
  RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token from "
		<< __FILE__ << ":" << lin
		<< " tksrc=" << *tksrc << std::endl
                << Rps_Do_Output([&](std::ostream& out)
  {
    tksrc->display_current_line_with_cursor(out);
  })
      << std::endl
      << RPS_FULL_BACKTRACE_HERE(1, "rps_carbrepl_next_token+"));
  RPS_POSSIBLE_BREAKPOINT();
  _f.tokv = tksrc->lookahead_token(&_, 0);
  _f.nextokv = tksrc->lookahead_token(&_, 1);
  RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token from "
		<< __FILE__ << ":" << lin
		<< " tksrc=" << *tksrc << std::endl
                << Rps_Do_Output([&](std::ostream& out)
  {
    tksrc->display_current_line_with_cursor(out);
  })
		<< std::endl /// REPL debugging ⌣ rps_carbrepl_next_token
		<< "+!tokv=" << _f.tokv << " nextokv=" << _f.nextokv
		<< " tksrc=" << *tksrc << std::endl
		<< RPS_FULL_BACKTRACE_HERE(1, "rps_carbrepl_next_token/b")
		<< " currentline=" << Rps_QuotedC_String(tksrc->current_line())
		<< " at " << tksrc->position_str());
  RPS_POSSIBLE_BREAKPOINT(); /// GDB could set gdb_do_return & gdb_returned
  RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token °gdb_do_return at "
		<< (void*)&gdb_do_return << " is "
		<< (gdb_do_return?"SET":"CLEARED")
		<< " gdb_returned at " << (void*)&gdb_returned
		<< " is " << gdb_returned);
  RPS_POSSIBLE_BREAKPOINT(); /// GDB could set gdb_do_return & gdb_returned
  //// temporary trick to help debugging with GDB
  asm volatile (".global carbrepl_rps_issue; nop; carbrepl_rps_issue: nop; nop; nop");
  RPS_ASSERT(&gdb_do_return != nullptr);
  RPS_POSSIBLE_BREAKPOINT(); /// GDB could set gdb_do_return & gdb_returned
  //// for GDB
  if (gdb_do_return) {
    RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token- tksrc=" << *tksrc
		  << " gdb_returned=" << gdb_returned);
    RPS_INFORMOUT("rps_carbrepl_next_token from- lin=" << lin
		  << " GDB returning " << gdb_returned);
    return gdb_returned;
  }
  else {
    RPS_POSSIBLE_BREAKPOINT();
    RPS_DEBUG_LOG(REPL, "rps_carbrepl_next_token- tksrc=" << *tksrc
		  << " tokv=" << _f.tokv << " nextokv=" << _f.nextokv
		  << " no gdb_do_return" << std::endl
		  << RPS_FULL_BACKTRACE_HERE(1, "rps_carbrepl_next_token-gdb"));
  };
  ////
  RPS_POSSIBLE_BREAKPOINT();
#warning unimplemented rps_carbrepl_next_token
  RPS_FATALOUT("unimplemented rps_carbrepl_next_token from "
	       << __FILE__ << ":" << lin
	       << std::endl << "..tksrc=" << *tksrc
	       << std::endl
                << Rps_Do_Output([&](std::ostream& out)
  {
    tksrc->display_current_line_with_cursor(out);
  })
      << std::endl << "tokv=" << _f.tokv);
} // end rps_carbrepl_next_token




void
rps_do_carburetta_tokensrc(Rps_CallFrame*callerframe, Rps_ObjectRef obenvarg,
                                Rps_TokenSource*tksrc,
                                const char*title)
{
  RPS_LOCALFRAME(/*descr:*/RPS_ROOT_OB(_4CZZ2JlnkQT02YJ6sM), //replnt_command∈symbol
                 callerframe,
                 Rps_ObjectRef obenv;
                );
  _Pragma("message \"rps_do_carburetta_tokensrc\"");
  RPS_ASSERT(tksrc);
  _f.obenv = obenvarg;
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_tokensrc starting obenv=" << _f.obenv
		<< " tksrc=" << *tksrc
		<< " from thread " << rps_current_pthread_name()
		<< RPS_FULL_BACKTRACE_HERE(1, "start rps_do_carburetta_tokensrc")
		<< std::endl);
  RPS_POSSIBLE_BREAKPOINT();
  struct rpscarbrepl_stack carbstack;
  memset ((void*)&carbstack, 0, sizeof(carbstack));
  rpscarbrepl_stack_init(&carbstack);
  _.set_additional_gc_marker([&](Rps_GarbageCollector*gc) {
    RPS_ASSERT(gc != nullptr);
    rpscarbrepl_stack_visit(&carbstack, gc);
    });
  RPS_ASSERT(callerframe && callerframe->is_good_call_frame());
  RPS_POSSIBLE_BREAKPOINT();
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_tokensrc obenv=" << _f.obenv
		<< " tksrc=" << *tksrc);
  RPS_POSSIBLE_BREAKPOINT();
#warning check this
  int r = rpscarbrepl_parse(&carbstack, /*sym:*/RPSCARBREPL_REPLNT_INPUT, tksrc, &_);
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_tokensrc after rpscarbrepl_parse r=" << r
		<< " obenv=" << _f.obenv
		<< " tksrc=" << *tksrc);
#warning unimplemented rps_do_carburetta_tokensrc
  /// TODO: should probably use generated scanning routines
  /// the last statement should be the following cleanup
  rpscarbrepl_stack_cleanup(&carbstack);
  RPS_POSSIBLE_BREAKPOINT();
} // end rps_do_carburetta_tokensrc



void
rps_do_carburetta_command(Rps_CallFrame*callerframe, Rps_ObjectRef obenvarg,
                                const std::string&cmd,
                                const char*title)
{
  RPS_LOCALFRAME(/*descr:*/RPS_ROOT_OB(_4CZZ2JlnkQT02YJ6sM), //replnt_command∈symbol
                 callerframe,
                 Rps_ObjectRef obenv;
                );
  _Pragma("message \"rps_do_carburetta_command\"");
  _f.obenv = obenvarg;
  RPS_ASSERT(callerframe && callerframe->is_good_call_frame());
  RPS_POSSIBLE_BREAKPOINT();
  Rps_StringTokenSource tokensrc(cmd, std::string(title));
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_command start tokensrc=" << tokensrc
		<< " obenv=" << RPS_OBJECT_DISPLAY(_f.obenv) << std::endl
		<< RPS_FULL_BACKTRACE_HERE(1, "rps_do_carburetta_command start"));
  RPS_POSSIBLE_BREAKPOINT();
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_command before rps_do_carburetta_tokensrc tokensrc="
		<< tokensrc);
  RPS_POSSIBLE_BREAKPOINT();
  rps_do_carburetta_tokensrc(&_, _f.obenv, &tokensrc, title);
  RPS_DEBUG_LOG(REPL, "rps_do_carburetta_command end tokensrc=" << tokensrc
		<< " obenv=" << _f.obenv << std::endl
		<< RPS_FULL_BACKTRACE_HERE(1, "rps_do_carburetta_command end"));
}  // end rps_do_carburetta_command



 void
 rps_carbrepl_do_display_command(Rps_CallFrame*callerframe, Rps_ObjectRef obenvarg, Rps_Value exprarg)
 {
   RPS_LOCALFRAME(RPS_ROOT_OB(_006mAbXTG4G00QR5HS), ///display∈symbol h:2127571271
		  callerframe,
		  Rps_ObjectRef obenv;
		  Rps_Value exprv;
		 );
   _f.obenv = obenvarg;
   _f.exprv = exprarg;
  RPS_ASSERT(callerframe && callerframe->is_good_call_frame());
  RPS_DEBUG_LOG(REPL, "rps_carbrepl_do_display_command starting obenv="
		<< RPS_OBJECT_DISPLAY(_f.obenv) << std::endl
		<< " expr=" << _f.exprv);
  RPS_POSSIBLE_BREAKPOINT();
  RPS_DEBUG_LOG(CMD, "carburetta display obenv=" << RPS_OBJECT_DISPLAY(_f.obenv) << std::endl
		<< "display expr=" << _f.exprv
                << std::endl
                << RPS_FULL_BACKTRACE_HERE(1, "carburetta command display"));
  RPS_POSSIBLE_BREAKPOINT();
#warning incomplete rps_do_display_carburetta_command
  // TODO: should evaluate exprv in obenv and display it
  RPS_WARNOUT("incomplete rps_carbrepl_do_display_command obenv=" << _f.obenv << " exprv=" << _f.exprv);
 } // end rps_carbrepl_do_display_command


void
rps_initialize_carburetta_after_load(Rps_Loader*ld)
{
  RPS_ASSERT(ld);
  rpskob_7LMYzEqjeDH00ZI1CO //$at_sign∈repl_delimiter h:150658742
    ->put_attr(rpskob_1cUbHIFNNXi00HOCWM/*carburetta_terminal*/,
	     Rps_Value::make_tagged_int(RPSCARBREPL_ATSIGN));
  rpskob_4YM7mv0GrSp03OkF8T //!leftparen!delim∈repl_delimiter
    ->put_attr(rpskob_1cUbHIFNNXi00HOCWM/*carburetta_terminal*/,
	     Rps_Value::make_tagged_int(RPSCARBREPL_LEFTPAREN));
  rpskob_7CG9m1NXpMo01edTUl //!rightparen!delim∈repl_delimiter
    ->put_attr(rpskob_1cUbHIFNNXi00HOCWM/*carburetta_terminal*/,
	     Rps_Value::make_tagged_int(RPSCARBREPL_RIGHTPAREN));

#warning incomplete rps_initialize_carburetta_after_load
  RPS_WARNOUT("incomplete rps_initialize_carburetta_after_load"
	      << std::endl
	      << RPS_FULL_BACKTRACE_HERE(1, "rps_initialize_carburetta_after_load"));
} // end rps_initialize_carburetta_after_load


////////////////////////////////////////////////////////////////
extern "C" const char rps_carbrepl_gitid[];
const char rps_carbrepl_gitid[]= RPS_GITID;

extern "C" const char rps_carbrepl_date[];
const char rps_carbrepl_date[]= __DATE__;

extern "C" const char rps_carbrepl_shortgitid[];
const char rps_carbrepl_shortgitid[]= RPS_SHORTGITID;

extern "C" const size_t rpscarbrepl_stack_size;
extern "C" const size_t rpscarbrepl_stack_align;

const size_t rpscarbrepl_stack_size = sizeof(struct rpscarbrepl_stack);
const size_t rpscarbrepl_stack_align = alignof(struct rpscarbrepl_stack);
/****************
 **                           for Emacs...
 ** Local Variables: ;;
 ** mode: c++ ;;
 ** compile-command: "make _carbrepl_rps.o && make" ;;
 ** End: ;;
 ****************/
